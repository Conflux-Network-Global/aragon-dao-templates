diff --git a/node_modules/@aragon/os/contracts/acl/ACL.sol b/node_modules/@aragon/os/contracts/acl/ACL.sol
index 032f556..00a48f4 100644
--- a/node_modules/@aragon/os/contracts/acl/ACL.sol
+++ b/node_modules/@aragon/os/contracts/acl/ACL.sol
@@ -42,8 +42,6 @@ contract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {
     address public constant ANY_ENTITY = address(-1);
     address public constant BURN_ENTITY = address(1); // address(0) is already used as "no permission manager"
 
-    uint256 internal constant ORACLE_CHECK_GAS = 30000;
-
     string private constant ERROR_AUTH_INIT_KERNEL = "ACL_AUTH_INIT_KERNEL";
     string private constant ERROR_AUTH_NO_MANAGER = "ACL_AUTH_NO_MANAGER";
     string private constant ERROR_EXISTENT_MANAGER = "ACL_EXISTENT_MANAGER";
@@ -75,8 +73,8 @@ contract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {
     * @notice Initialize an ACL instance and set `_permissionsCreator` as the entity that can create other permissions
     * @param _permissionsCreator Entity that will be given permission over createPermission
     */
-    function initialize(address _permissionsCreator) public onlyInit {
-        initialized();
+    function initialize(address _permissionsCreator, uint256 epoch) public onlyInit {
+        initialized(epoch);
         require(msg.sender == address(kernel()), ERROR_AUTH_INIT_KERNEL);
 
         _createPermission(_permissionsCreator, this, CREATE_PERMISSIONS_ROLE, _permissionsCreator);
@@ -421,11 +419,13 @@ contract ACL is IACL, TimeHelpers, AragonApp, ACLHelpers {
 
         // a raw call is required so we can return false if the call reverts, rather than reverting
         bytes memory checkCalldata = abi.encodeWithSelector(sig, _who, _where, _what, _how);
-        uint256 oracleCheckGas = ORACLE_CHECK_GAS;
 
         bool ok;
         assembly {
-            ok := staticcall(oracleCheckGas, _oracleAddr, add(checkCalldata, 0x20), mload(checkCalldata), 0, 0)
+            // send all available gas; if the oracle eats up all the gas, we will eventually revert
+            // note that we are currently guaranteed to still have some gas after the call from
+            // EIP-150's 63/64 gas forward rule
+            ok := staticcall(gas, _oracleAddr, add(checkCalldata, 0x20), mload(checkCalldata), 0, 0)
         }
 
         if (!ok) {
diff --git a/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol b/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol
index f5683c0..d27f4aa 100644
--- a/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol
+++ b/node_modules/@aragon/os/contracts/acl/ACLSyntaxSugar.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/acl/IACL.sol b/node_modules/@aragon/os/contracts/acl/IACL.sol
index cf28251..bbfaf67 100644
--- a/node_modules/@aragon/os/contracts/acl/IACL.sol
+++ b/node_modules/@aragon/os/contracts/acl/IACL.sol
@@ -1,12 +1,12 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
 
 
 interface IACL {
-    function initialize(address permissionsCreator) external;
+    function initialize(address permissionsCreator, uint256 epoch) external;
 
     // TODO: this should be external
     // See https://github.com/ethereum/solidity/issues/4832
diff --git a/node_modules/@aragon/os/contracts/acl/IACLOracle.sol b/node_modules/@aragon/os/contracts/acl/IACLOracle.sol
index 802537f..e837d3a 100644
--- a/node_modules/@aragon/os/contracts/acl/IACLOracle.sol
+++ b/node_modules/@aragon/os/contracts/acl/IACLOracle.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/apm/APMNamehash.sol b/node_modules/@aragon/os/contracts/apm/APMNamehash.sol
index fda755f..69f0d0e 100644
--- a/node_modules/@aragon/os/contracts/apm/APMNamehash.sol
+++ b/node_modules/@aragon/os/contracts/apm/APMNamehash.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/apm/APMRegistry.sol b/node_modules/@aragon/os/contracts/apm/APMRegistry.sol
index 1a0ae42..712e2a1 100644
--- a/node_modules/@aragon/os/contracts/apm/APMRegistry.sol
+++ b/node_modules/@aragon/os/contracts/apm/APMRegistry.sol
@@ -35,8 +35,8 @@ contract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {
     * @notice Initialize this APMRegistry instance and set `_registrar` as the ENS subdomain registrar
     * @param _registrar ENSSubdomainRegistrar instance that holds registry root node ownership
     */
-    function initialize(ENSSubdomainRegistrar _registrar) public onlyInit {
-        initialized();
+    function initialize(ENSSubdomainRegistrar _registrar, uint256 epoch) public onlyInit {
+        initialized(epoch);
 
         registrar = _registrar;
         ens = registrar.ens();
@@ -54,8 +54,8 @@ contract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {
     * @param _name Repo name, must be ununsed
     * @param _dev Address that will be given permission to create versions
     */
-    function newRepo(string _name, address _dev) public auth(CREATE_REPO_ROLE) returns (Repo) {
-        return _newRepo(_name, _dev);
+    function newRepo(string _name, address _dev, uint256 epoch) public auth(CREATE_REPO_ROLE) returns (Repo) {
+        return _newRepo(_name, _dev, epoch);
     }
 
     /**
@@ -71,10 +71,11 @@ contract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {
         address _dev,
         uint16[3] _initialSemanticVersion,
         address _contractAddress,
-        bytes _contentURI
+        bytes _contentURI,
+        uint256 epoch
     ) public auth(CREATE_REPO_ROLE) returns (Repo)
     {
-        Repo repo = _newRepo(_name, this); // need to have permissions to create version
+        Repo repo = _newRepo(_name, this, epoch); // need to have permissions to create version
         repo.newVersion(_initialSemanticVersion, _contractAddress, _contentURI);
 
         // Give permissions to _dev
@@ -85,10 +86,10 @@ contract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {
         return repo;
     }
 
-    function _newRepo(string _name, address _dev) internal returns (Repo) {
+    function _newRepo(string _name, address _dev, uint256 epoch) internal returns (Repo) {
         require(bytes(_name).length > 0, ERROR_EMPTY_NAME);
 
-        Repo repo = newClonedRepo();
+        Repo repo = newClonedRepo(epoch);
 
         ACL(kernel().acl()).createPermission(_dev, repo, repo.CREATE_VERSION_ROLE(), _dev);
 
@@ -101,9 +102,9 @@ contract APMRegistry is AragonApp, AppProxyFactory, APMInternalAppNames {
         return repo;
     }
 
-    function newClonedRepo() internal returns (Repo repo) {
+    function newClonedRepo(uint256 epoch) internal returns (Repo repo) {
         repo = Repo(newAppProxy(kernel(), repoAppId()));
-        repo.initialize();
+        repo.initialize(epoch);
     }
 
     function repoAppId() internal view returns (bytes32) {
diff --git a/node_modules/@aragon/os/contracts/apm/Repo.sol b/node_modules/@aragon/os/contracts/apm/Repo.sol
index 0cb73c2..da3f481 100644
--- a/node_modules/@aragon/os/contracts/apm/Repo.sol
+++ b/node_modules/@aragon/os/contracts/apm/Repo.sol
@@ -32,8 +32,8 @@ contract Repo is AragonApp {
     * @dev Initialize can only be called once. It saves the block number in which it was initialized.
     * @notice Initialize this Repo
     */
-    function initialize() public onlyInit {
-        initialized();
+    function initialize(uint256 epoch) public onlyInit {
+        initialized(epoch);
         versionsNextIndex = 1;
     }
 
diff --git a/node_modules/@aragon/os/contracts/apps/AppStorage.sol b/node_modules/@aragon/os/contracts/apps/AppStorage.sol
index b37dd36..07f601d 100644
--- a/node_modules/@aragon/os/contracts/apps/AppStorage.sol
+++ b/node_modules/@aragon/os/contracts/apps/AppStorage.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/apps/AragonApp.sol b/node_modules/@aragon/os/contracts/apps/AragonApp.sol
index f53c407..b31cce7 100644
--- a/node_modules/@aragon/os/contracts/apps/AragonApp.sol
+++ b/node_modules/@aragon/os/contracts/apps/AragonApp.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/apps/UnsafeAragonApp.sol b/node_modules/@aragon/os/contracts/apps/UnsafeAragonApp.sol
index 7e46b7a..032571e 100644
--- a/node_modules/@aragon/os/contracts/apps/UnsafeAragonApp.sol
+++ b/node_modules/@aragon/os/contracts/apps/UnsafeAragonApp.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/cfx-extensions/EpochRegistry.sol b/node_modules/@aragon/os/contracts/cfx-extensions/EpochRegistry.sol
new file mode 100644
index 0000000..f4d0f57
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/cfx-extensions/EpochRegistry.sol
@@ -0,0 +1,22 @@
+pragma solidity 0.4.24;
+
+
+contract EpochRegistry {
+
+    string private constant ERROR_UNAUTHORIZED = "UNAUTHORIZED";
+
+    address daoFactory;
+    mapping (uint256 => uint256) public blockToEpochNumber;
+
+    event NewEpochRegistry(address registry, address daoFactory);
+
+    constructor() {
+        daoFactory = msg.sender;
+        emit NewEpochRegistry(address(this), daoFactory);
+    }
+
+    function register(uint256 currentEpoch) {
+        require(msg.sender == daoFactory, ERROR_UNAUTHORIZED);
+        blockToEpochNumber[block.number] = currentEpoch;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/common/Autopetrified.sol b/node_modules/@aragon/os/contracts/common/Autopetrified.sol
index 1224319..0004f35 100644
--- a/node_modules/@aragon/os/contracts/common/Autopetrified.sol
+++ b/node_modules/@aragon/os/contracts/common/Autopetrified.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol b/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol
index 63a512b..81c4e05 100644
--- a/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol
+++ b/node_modules/@aragon/os/contracts/common/EtherTokenConstant.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/IForwarder.sol b/node_modules/@aragon/os/contracts/common/IForwarder.sol
index 5876f46..a54b8cf 100644
--- a/node_modules/@aragon/os/contracts/common/IForwarder.sol
+++ b/node_modules/@aragon/os/contracts/common/IForwarder.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/IForwarderFee.sol b/node_modules/@aragon/os/contracts/common/IForwarderFee.sol
index 80913fe..0fecb34 100644
--- a/node_modules/@aragon/os/contracts/common/IForwarderFee.sol
+++ b/node_modules/@aragon/os/contracts/common/IForwarderFee.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol b/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol
index 3c8c367..8d0e284 100644
--- a/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol
+++ b/node_modules/@aragon/os/contracts/common/IVaultRecoverable.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/Initializable.sol b/node_modules/@aragon/os/contracts/common/Initializable.sol
index d267ab2..c7c332b 100644
--- a/node_modules/@aragon/os/contracts/common/Initializable.sol
+++ b/node_modules/@aragon/os/contracts/common/Initializable.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
@@ -14,6 +14,9 @@ contract Initializable is TimeHelpers {
     // keccak256("aragonOS.initializable.initializationBlock")
     bytes32 internal constant INITIALIZATION_BLOCK_POSITION = 0xebb05b386a8d34882b8711d156f463690983dc47815980fb82aeeff1aa43579e;
 
+    // keccak256("aragonOS.initializable.initializationEpoch")
+    bytes32 internal constant INITIALIZATION_EPOCH_POSITION = 0xe7fa44a35a50de89802e274b5f39cb40d0e298b7ffd493afac2f8960c0601af0;
+
     string private constant ERROR_ALREADY_INITIALIZED = "INIT_ALREADY_INITIALIZED";
     string private constant ERROR_NOT_INITIALIZED = "INIT_NOT_INITIALIZED";
 
@@ -34,6 +37,13 @@ contract Initializable is TimeHelpers {
         return INITIALIZATION_BLOCK_POSITION.getStorageUint256();
     }
 
+    /**
+    * @return Epoch number in which the contract was initialized
+    */
+    function getInitializationEpoch() public view returns (uint256) {
+        return INITIALIZATION_EPOCH_POSITION.getStorageUint256();
+    }
+
     /**
     * @return Whether the contract has been initialized by the time of the current block
     */
@@ -45,8 +55,9 @@ contract Initializable is TimeHelpers {
     /**
     * @dev Function to be called by top level contract after initialization has finished.
     */
-    function initialized() internal onlyInit {
+    function initialized(uint256 epoch) internal onlyInit {
         INITIALIZATION_BLOCK_POSITION.setStorageUint256(getBlockNumber());
+        INITIALIZATION_EPOCH_POSITION.setStorageUint256(epoch);
     }
 
     /**
diff --git a/node_modules/@aragon/os/contracts/common/IsContract.sol b/node_modules/@aragon/os/contracts/common/IsContract.sol
index 9c5d412..531ce47 100644
--- a/node_modules/@aragon/os/contracts/common/IsContract.sol
+++ b/node_modules/@aragon/os/contracts/common/IsContract.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/Petrifiable.sol b/node_modules/@aragon/os/contracts/common/Petrifiable.sol
index bd7803e..bb534d2 100644
--- a/node_modules/@aragon/os/contracts/common/Petrifiable.sol
+++ b/node_modules/@aragon/os/contracts/common/Petrifiable.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/ReentrancyGuard.sol b/node_modules/@aragon/os/contracts/common/ReentrancyGuard.sol
index 0d761f2..b2de848 100644
--- a/node_modules/@aragon/os/contracts/common/ReentrancyGuard.sol
+++ b/node_modules/@aragon/os/contracts/common/ReentrancyGuard.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/TimeHelpers.sol b/node_modules/@aragon/os/contracts/common/TimeHelpers.sol
index cb99933..92ec1f8 100644
--- a/node_modules/@aragon/os/contracts/common/TimeHelpers.sol
+++ b/node_modules/@aragon/os/contracts/common/TimeHelpers.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/UnstructuredStorage.sol b/node_modules/@aragon/os/contracts/common/UnstructuredStorage.sol
index db0a56d..a231233 100644
--- a/node_modules/@aragon/os/contracts/common/UnstructuredStorage.sol
+++ b/node_modules/@aragon/os/contracts/common/UnstructuredStorage.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol b/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol
index 74aacd4..e9bf2b1 100644
--- a/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol
+++ b/node_modules/@aragon/os/contracts/common/VaultRecoverable.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/ens/ENSConstants.sol b/node_modules/@aragon/os/contracts/ens/ENSConstants.sol
index 5069408..bcbe0d9 100644
--- a/node_modules/@aragon/os/contracts/ens/ENSConstants.sol
+++ b/node_modules/@aragon/os/contracts/ens/ENSConstants.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/ens/ENSSubdomainRegistrar.sol b/node_modules/@aragon/os/contracts/ens/ENSSubdomainRegistrar.sol
index 9fa8811..8dd848e 100644
--- a/node_modules/@aragon/os/contracts/ens/ENSSubdomainRegistrar.sol
+++ b/node_modules/@aragon/os/contracts/ens/ENSSubdomainRegistrar.sol
@@ -35,8 +35,8 @@ contract ENSSubdomainRegistrar is AragonApp, ENSConstants {
     * @param _ens Address of ENS registry
     * @param _rootNode Node to allocate subdomains under
     */
-    function initialize(AbstractENS _ens, bytes32 _rootNode) public onlyInit {
-        initialized();
+    function initialize(AbstractENS _ens, bytes32 _rootNode, uint256 epoch) public onlyInit {
+        initialized(epoch);
 
         // We need ownership to create subnodes
         require(_ens.owner(_rootNode) == address(this), ERROR_NO_NODE_OWNERSHIP);
diff --git a/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol b/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol
index 7eb8dd3..d208a51 100644
--- a/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/EVMScriptRegistry.sol
@@ -45,8 +45,8 @@ contract EVMScriptRegistry is IEVMScriptRegistry, EVMScriptRegistryConstants, Ar
     /**
     * @notice Initialize the registry
     */
-    function initialize() public onlyInit {
-        initialized();
+    function initialize(uint256 epoch) public onlyInit {
+        initialized(epoch);
         // Create empty record to begin executor IDs at 1
         executorsNextIndex = 1;
     }
diff --git a/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol b/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol
index 576dfa1..c2f5a5d 100644
--- a/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/EVMScriptRunner.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol b/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol
index ffa0368..d326988 100644
--- a/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/IEVMScriptExecutor.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol b/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol
index d6cfddb..6e4ed0f 100644
--- a/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/IEVMScriptRegistry.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol b/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol
index bdf26d3..aee2379 100644
--- a/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/ScriptHelpers.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/evmscript/executors/BaseEVMScriptExecutor.sol b/node_modules/@aragon/os/contracts/evmscript/executors/BaseEVMScriptExecutor.sol
index 6802c10..ff78d8c 100644
--- a/node_modules/@aragon/os/contracts/evmscript/executors/BaseEVMScriptExecutor.sol
+++ b/node_modules/@aragon/os/contracts/evmscript/executors/BaseEVMScriptExecutor.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/factory/APMRegistryFactory.sol b/node_modules/@aragon/os/contracts/factory/APMRegistryFactory.sol
index 7f0aa3f..74362b6 100644
--- a/node_modules/@aragon/os/contracts/factory/APMRegistryFactory.sol
+++ b/node_modules/@aragon/os/contracts/factory/APMRegistryFactory.sol
@@ -56,7 +56,7 @@ contract APMRegistryFactory is APMInternalAppNames {
     * @param _root Manager for the new aragonPM DAO
     * @return The new aragonPM's APMRegistry app
     */
-    function newAPM(bytes32 _tld, bytes32 _label, address _root) public returns (APMRegistry) {
+    function newAPM(bytes32 _tld, bytes32 _label, address _root, uint256 epoch) public returns (APMRegistry) {
         bytes32 node = keccak256(abi.encodePacked(_tld, _label));
 
         // Assume it is the test ENS
@@ -66,18 +66,18 @@ contract APMRegistryFactory is APMInternalAppNames {
             ens.setSubnodeOwner(_tld, _label, this);
         }
 
-        Kernel dao = daoFactory.newDAO(this);
+        Kernel dao = daoFactory.newDAO(this, epoch);
         ACL acl = ACL(dao.acl());
 
         acl.createPermission(this, dao, dao.APP_MANAGER_ROLE(), this);
 
         // Deploy app proxies
-        bytes memory noInit = new bytes(0);
+        // bytes memory noInit = new bytes(0);
         ENSSubdomainRegistrar ensSub = ENSSubdomainRegistrar(
             dao.newAppInstance(
                 keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(ENS_SUB_APP_NAME)))),
                 ensSubdomainRegistrarBase,
-                noInit,
+                new bytes(0), // noInit
                 false
             )
         );
@@ -85,7 +85,7 @@ contract APMRegistryFactory is APMInternalAppNames {
             dao.newAppInstance(
                 keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(APM_APP_NAME)))),
                 registryBase,
-                noInit,
+                new bytes(0), // noInit
                 false
             )
         );
@@ -107,17 +107,17 @@ contract APMRegistryFactory is APMInternalAppNames {
 
         // Initialize
         ens.setOwner(node, ensSub);
-        ensSub.initialize(ens, node);
-        apm.initialize(ensSub);
+        ensSub.initialize(ens, node, epoch);
+        apm.initialize(ensSub, epoch);
 
-        uint16[3] memory firstVersion;
-        firstVersion[0] = 1;
+        // uint16[3] memory firstVersion;
+        // firstVersion[0] = 1;
 
         acl.createPermission(this, apm, apm.CREATE_REPO_ROLE(), this);
 
-        apm.newRepoWithVersion(APM_APP_NAME, _root, firstVersion, registryBase, b("ipfs:apm"));
-        apm.newRepoWithVersion(ENS_SUB_APP_NAME, _root, firstVersion, ensSubdomainRegistrarBase, b("ipfs:enssub"));
-        apm.newRepoWithVersion(REPO_APP_NAME, _root, firstVersion, repoBase, b("ipfs:repo"));
+        apm.newRepoWithVersion(APM_APP_NAME, _root, [uint16(1), 0, 0], registryBase, b("ipfs:apm"), epoch);
+        apm.newRepoWithVersion(ENS_SUB_APP_NAME, _root, [uint16(1), 0, 0], ensSubdomainRegistrarBase, b("ipfs:enssub"), epoch);
+        apm.newRepoWithVersion(REPO_APP_NAME, _root, [uint16(1), 0, 0], repoBase, b("ipfs:repo"), epoch);
 
         configureAPMPermissions(acl, apm, _root);
 
diff --git a/node_modules/@aragon/os/contracts/factory/DAOFactory.sol b/node_modules/@aragon/os/contracts/factory/DAOFactory.sol
index a2eec70..892107d 100644
--- a/node_modules/@aragon/os/contracts/factory/DAOFactory.sol
+++ b/node_modules/@aragon/os/contracts/factory/DAOFactory.sol
@@ -39,13 +39,13 @@ contract DAOFactory {
     * @param _root Address that will be granted control to setup DAO permissions
     * @return Newly created DAO
     */
-    function newDAO(address _root) public returns (Kernel) {
+    function newDAO(address _root, uint256 epoch) public returns (Kernel) {
         Kernel dao = Kernel(new KernelProxy(baseKernel));
 
         if (address(regFactory) == address(0)) {
-            dao.initialize(baseACL, _root);
+            dao.initialize(baseACL, _root, epoch);
         } else {
-            dao.initialize(baseACL, this);
+            dao.initialize(baseACL, this, epoch);
 
             ACL acl = ACL(dao.acl());
             bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();
diff --git a/node_modules/@aragon/os/contracts/kernel/IKernel.sol b/node_modules/@aragon/os/contracts/kernel/IKernel.sol
index e1a2b40..1686e77 100644
--- a/node_modules/@aragon/os/contracts/kernel/IKernel.sol
+++ b/node_modules/@aragon/os/contracts/kernel/IKernel.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/kernel/Kernel.sol b/node_modules/@aragon/os/contracts/kernel/Kernel.sol
index 1fc9190..782e889 100644
--- a/node_modules/@aragon/os/contracts/kernel/Kernel.sol
+++ b/node_modules/@aragon/os/contracts/kernel/Kernel.sol
@@ -40,15 +40,15 @@ contract Kernel is IKernel, KernelStorage, KernelAppIds, KernelNamespaceConstant
     * @param _baseAcl Address of base ACL app
     * @param _permissionsCreator Entity that will be given permission over createPermission
     */
-    function initialize(IACL _baseAcl, address _permissionsCreator) public onlyInit {
-        initialized();
+    function initialize(IACL _baseAcl, address _permissionsCreator, uint256 epoch) public onlyInit {
+        initialized(epoch);
 
         // Set ACL base
         _setApp(KERNEL_APP_BASES_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, _baseAcl);
 
         // Create ACL instance and attach it as the default ACL app
         IACL acl = IACL(newAppProxy(this, KERNEL_DEFAULT_ACL_APP_ID));
-        acl.initialize(_permissionsCreator);
+        acl.initialize(_permissionsCreator, epoch);
         _setApp(KERNEL_APP_ADDR_NAMESPACE, KERNEL_DEFAULT_ACL_APP_ID, acl);
 
         recoveryVaultAppId = KERNEL_DEFAULT_VAULT_APP_ID;
diff --git a/node_modules/@aragon/os/contracts/kernel/KernelConstants.sol b/node_modules/@aragon/os/contracts/kernel/KernelConstants.sol
index 77816a7..3406dab 100644
--- a/node_modules/@aragon/os/contracts/kernel/KernelConstants.sol
+++ b/node_modules/@aragon/os/contracts/kernel/KernelConstants.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol b/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol
index 4311587..e7ddc1f 100644
--- a/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol
+++ b/node_modules/@aragon/os/contracts/lib/misc/ERCProxy.sol
@@ -1,5 +1,5 @@
 /*
- * SPDX-License-Identitifer:    MIT
+ * SPDX-License-Identifier:    MIT
  */
 
 pragma solidity ^0.4.24;
diff --git a/node_modules/@aragon/os/contracts/test/helpers/ACLHelper.sol b/node_modules/@aragon/os/contracts/test/helpers/ACLHelper.sol
new file mode 100644
index 0000000..265d6a8
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/helpers/ACLHelper.sol
@@ -0,0 +1,76 @@
+pragma solidity 0.4.24;
+
+import "../../acl/IACLOracle.sol";
+
+
+contract ACLHelper {
+    function encodeOperator(uint256 param1, uint256 param2) internal pure returns (uint240) {
+        return encodeIfElse(param1, param2, 0);
+    }
+
+    function encodeIfElse(uint256 condition, uint256 successParam, uint256 failureParam) internal pure returns (uint240) {
+        return uint240(condition + (successParam << 32) + (failureParam << 64));
+    }
+}
+
+
+contract AcceptOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        return true;
+    }
+}
+
+
+contract RejectOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        return false;
+    }
+}
+
+
+contract RevertOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        revert();
+    }
+}
+
+contract AssertOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        assert(false);
+    }
+}
+
+// Can't implement from IACLOracle as its canPerform() is marked as view-only
+contract StateModifyingOracle /* is IACLOracle */ {
+    bool modifyState;
+
+    function canPerform(address, address, bytes32, uint256[]) external returns (bool) {
+        modifyState = true;
+        return true;
+    }
+}
+
+contract EmptyDataReturnOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        assembly {
+            return(0, 0)
+        }
+    }
+}
+
+contract ConditionalOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[] how) external view returns (bool) {
+        return how[0] > 0;
+    }
+}
+
+contract OverGasLimitOracle is IACLOracle {
+    function canPerform(address, address, bytes32, uint256[]) external view returns (bool) {
+        while (true) {
+            // Do an SLOAD to increase the per-loop gas costs
+            uint256 loadFromStorage;
+            assembly { loadFromStorage := sload(0) }
+        }
+        return true;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/helpers/Assert.sol b/node_modules/@aragon/os/contracts/test/helpers/Assert.sol
new file mode 100644
index 0000000..a1b39c8
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/helpers/Assert.sol
@@ -0,0 +1,1403 @@
+// Taken from https://github.com/trufflesuite/truffle/blob/ef03be9e35909e5e7c97a9ecb07ccae4872645ca/packages/truffle-core/lib/testing/Assert.sol
+
+pragma solidity ^0.4.17;
+
+/*
+    File: Assertions.slb
+    Author: Andreas Olofsson (androlo1980@gmail.com)
+    Library: Assertions
+    Assertions for unit testing contracts. Tests are run with the
+    <solUnit at https://github.com/smartcontractproduction/sol-unit>
+    unit-testing framework.
+    (start code)
+    contract ModAdder {
+        function addMod(uint a, uint b, uint modulus) constant returns (uint sum) {
+            if (modulus == 0)
+                throw;
+            return addmod(a, b, modulus);
+        }
+    }
+    contract SomeTest {
+        using Assertions for uint;
+        function testAdd() {
+            var adder = new ModAdder();
+            adder.addMod(50, 66, 30).equal(26, "addition returned the wrong sum");
+        }
+    }
+    (end)
+    It is also possible to extend <Test>, to have all bindings (using) properly set up.
+    (start code)
+    contract SomeTest is Test {
+        function testAdd() {
+            var adder = new ModAdder();
+            adder.addMod(50, 66, 30).equal(26, "addition returned the wrong sum");
+        }
+    }
+    (end)
+*/
+library Assert {
+
+    // Constant: ADDRESS_NULL
+    // The null address: 0
+    address constant ADDRESS_NULL = 0x0000000000000000000000000000000000000000;
+    // Constant: BYTES32_NULL
+    // The null bytes32: 0
+    bytes32 constant BYTES32_NULL = 0x0;
+    // Constant: STRING_NULL
+    // The null string: ""
+    string constant STRING_NULL = "";
+
+    uint8 constant ZERO = uint8(byte('0'));
+    uint8 constant A = uint8(byte('a'));
+
+    byte constant MINUS = byte('-');
+
+    /*
+        Event: TestEvent
+        Fired when an assertion is made.
+        Params:
+            result (bool) - Whether or not the assertion holds.
+            message (string) - A message to display if the assertion does not hold.
+    */
+    event TestEvent(bool indexed result, string message);
+
+    // ************************************** general **************************************
+
+    /*
+        Function: fail()
+        Mark the test as failed.
+        Params:
+            message (string) - A message associated with the failure.
+        Returns:
+            result (bool) - false.
+    */
+    function fail(string message) public returns (bool result) {
+        _report(false, message);
+        return false;
+    }
+
+    // ************************************** strings **************************************
+
+    /*
+        Function: equal(string)
+        Assert that two strings are equal.
+        : _stringsEqual(A, B) == true
+        Params:
+            A (string) - The first string.
+            B (string) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(string a, string b, string message) public returns (bool result) {
+        result = _stringsEqual(a, b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: notEqual(string)
+        Assert that two strings are not equal.
+        : _stringsEqual(A, B) == false
+        Params:
+            A (string) - The first string.
+            B (string) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(string a, string b, string message) public returns (bool result) {
+        result = !_stringsEqual(a, b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isEmpty(string)
+        Assert that a string is empty.
+        : _stringsEqual(str, STRING_NULL) == true
+        Params:
+            str (string) - The string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isEmpty(string str, string message) public returns (bool result) {
+        result = _stringsEqual(str, STRING_NULL);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(str, "Tested"), message));
+    }
+
+    /*
+        Function: isNotEmpty(string)
+        Assert that a string is not empty.
+        : _stringsEqual(str, STRING_NULL) == false
+        Params:
+            str (string) - The string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isNotEmpty(string str, string message) public returns (bool result) {
+        result = !_stringsEqual(str, STRING_NULL);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(str, "Tested"), message));
+    }
+
+    // ************************************** bytes32 **************************************
+
+    /*
+        Function: equal(bytes32)
+        Assert that two 'bytes32' are equal.
+        : A == B
+        Params:
+            A (bytes32) - The first 'bytes32'.
+            B (bytes32) - The second 'bytes32'.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(bytes32 a, bytes32 b, string message) public returns (bool result) {
+        result = (a == b);
+        _report(result, message);
+    }
+
+    /*
+        Function: notEqual(bytes32)
+        Assert that two 'bytes32' are not equal.
+        : A != B
+        Params:
+            A (bytes32) - The first 'bytes32'.
+            B (bytes32) - The second 'bytes32'.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(bytes32 a, bytes32 b, string message) public returns (bool result) {
+        result = (a != b);
+        _report(result, message);
+    }
+
+    /*
+        Function: isZero(bytes32)
+        Assert that a 'bytes32' is zero.
+        : bts == BYTES32_NULL
+        Params:
+            bts (bytes32) - The 'bytes32'.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isZero(bytes32 bts, string message) public returns (bool result) {
+        result = (bts == BYTES32_NULL);
+        _report(result, message);
+    }
+
+    /*
+        Function: isNotZero(bytes32)
+        Assert that a 'bytes32' is not zero.
+        : bts != BYTES32_NULL
+        Params:
+            bts (bytes32) - The 'bytes32'.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isNotZero(bytes32 bts, string message) public returns (bool result) {
+        result = (bts != BYTES32_NULL);
+        _report(result, message);
+    }
+
+    // ************************************** address **************************************
+
+    /*
+        Function: equal(address)
+        Assert that two addresses are equal.
+        : A == B
+        Params:
+            A (address) - The first address.
+            B (address) - The second address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(address a, address b, string message) public returns (bool result) {
+        result = (a == b);
+        _report(result, message);
+    }
+    /*
+        Function: notEqual(address)
+        Assert that two addresses are not equal.
+        : A != B
+        Params:
+            A (address) - The first address.
+            B (address) - The second address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(address a, address b, string message) public returns (bool result) {
+        result = (a != b);
+         _report(result, message);
+    }
+
+    /*
+        Function: isZero(address)
+        Assert that an address is zero.
+        : addr == ADDRESS_NULL
+        Params:
+            addr (address) - The address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isZero(address addr, string message) public returns (bool result) {
+        result = (addr == ADDRESS_NULL);
+        _report(result, message);
+    }
+
+    /*
+        Function: isNotZero(address)
+        Assert that an address is not zero.
+        : addr != ADDRESS_NULL
+        Params:
+            addr (address) - The address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isNotZero(address addr, string message) public returns (bool result) {
+        result = (addr != ADDRESS_NULL);
+        _report(result, message);
+    }
+
+    // ************************************** bool **************************************
+
+    /*
+        Function: isTrue
+        Assert that a boolean is 'true'.
+        : b == true
+        Params:
+            b (bool) - The boolean.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isTrue(bool b, string message) public returns (bool result) {
+        result = b;
+        _report(result, message);
+    }
+
+    /*
+        Function: isFalse
+        Assert that a boolean is 'false'.
+        : b == false
+        Params:
+            b (bool) - The boolean.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isFalse(bool b, string message) public returns (bool result) {
+        result = !b;
+        _report(result, message);
+    }
+
+    /*
+        Function: equal(bool)
+        Assert that two booleans are equal.
+        : A == B
+        Params:
+            A (bool) - The first boolean.
+            B (bool) - The second boolean.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(bool a, bool b, string message) public returns (bool result) {
+        result = (a == b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: notEqual(bool)
+        Assert that two booleans are not equal.
+        : A != B
+        Params:
+            A (bool) - The first boolean.
+            B (bool) - The second boolean.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(bool a, bool b, string message) public returns (bool result) {
+        result = (a != b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    // ************************************** uint **************************************
+
+    /*
+        Function: equal(uint)
+        Assert that two (256 bit) unsigned integers are equal.
+        : A == B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(uint a, uint b, string message) public returns (bool result) {
+        result = (a == b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: notEqual(uint)
+        Assert that two (256 bit) unsigned integers are not equal.
+        : A != B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(uint a, uint b, string message) public returns (bool result) {
+        result = (a != b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAbove(uint)
+        Assert that the uint 'A' is greater than the uint 'B'.
+        : A > B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAbove(uint a, uint b, string message) public returns (bool result) {
+        result = (a > b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAtLeast(uint)
+        Assert that the uint 'A' is greater than or equal to the uint 'B'.
+        : A >= B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAtLeast(uint a, uint b, string message) public returns (bool result) {
+        result = (a >= b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isBelow(uint)
+        Assert that the uint 'A' is lesser than the uint 'B'.
+        : A < B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isBelow(uint a, uint b, string message) public returns (bool result) {
+        result = (a < b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAtMost(uint)
+        Assert that the uint 'A' is lesser than or equal to the uint 'B'.
+        : A <= B
+        Params:
+            A (uint) - The first uint.
+            B (uint) - The second uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAtMost(uint a, uint b, string message) public returns (bool result) {
+        result = (a <= b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isZero(uint)
+        Assert that a (256 bit) unsigned integer is 0.
+        : number == 0
+        Params:
+            number (uint) - The uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isZero(uint number, string message) public returns (bool result) {
+        result = (number == 0);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(number, "Tested"), message));
+    }
+
+    /*
+        Function: isNotZero(uint)
+        Assert that a (256 bit) unsigned integer is not 0.
+        : number != 0
+        Params:
+            number (uint) - The uint.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isNotZero(uint number, string message) public returns (bool result) {
+        result = (number != 0);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(number, "Tested"), message));
+    }
+
+    // ************************************** int **************************************
+
+    /*
+        Function: equal(int)
+        Assert that two (256 bit) signed integers are equal.
+        : A == B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(int a, int b, string message) public returns (bool result) {
+        result = (a == b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: notEqual(int)
+        Assert that two (256 bit) signed integers are not equal.
+        : A != B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(int a, int b, string message) public returns (bool result) {
+        result = (a != b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAbove(int)
+        Assert that the int 'A' is greater than the int 'B'.
+        : A > B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAbove(int a, int b, string message) public returns (bool result) {
+        result = (a > b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAtLeast(int)
+        Assert that the int 'A' is greater than or equal to the int 'B'.
+        : A >= B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAtLeast(int a, int b, string message) public returns (bool result) {
+        result = (a >= b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isBelow(int)
+        Assert that the int 'A' is lesser than the int 'B'.
+        : A < B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isBelow(int a, int b, string message) public returns (bool result) {
+        result = (a < b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isAtMost(int)
+        Assert that the int 'A' is lesser than or equal to the int 'B'.
+        : A <= B
+        Params:
+            A (int) - The first int.
+            B (int) - The second int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isAtMost(int a, int b, string message) public returns (bool result) {
+        result = (a <= b);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(a, "Tested"), _tag(b, "Against"), message));
+    }
+
+    /*
+        Function: isZero(int)
+        Assert that a (256 bit) signed integer is 0.
+        : number == 0
+        Params:
+            number (int) - The int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isZero(int number, string message) public returns (bool result) {
+        result = (number == 0);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(number, "Tested"), message));
+    }
+
+    /*
+        Function: isNotZero(int)
+        Assert that a (256 bit) signed integer is not 0.
+        : number != 0
+        Params:
+            number (int) - The int.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function isNotZero(int number, string message) public returns (bool result) {
+        result = (number != 0);
+        if (result)
+            _report(result, message);
+        else
+            _report(result, _appendTagged(_tag(number, "Tested"), message));
+    }
+
+    // ************************************** uint[] **************************************
+
+    /*
+        Function: equal(uint[])
+        Assert that two 'uint[ ]' are equal.
+        : arrA.length == arrB.length
+        and, for all valid indices 'i'
+        : arrA[i] == arrB[i]
+        Params:
+            A (uint[]) - The first array.
+            B (uint[]) - The second array.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(uint[] arrA, uint[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        _report(result, message);
+    }
+
+    /*
+        Function: notEqual(uint[])
+        Assert that two 'uint[]' are not equal.
+        : arrA.length != arrB.length
+        or, for some valid index 'i'
+        : arrA[i] != arrB[i]
+        Params:
+            A (uint[]) - The first string.
+            B (uint[]) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(uint[] arrA, uint[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        result = !result;
+        _report(result, message);
+    }
+
+    /*
+        Function: lengthEqual(uint[])
+        Assert that the length of a 'uint[]' is equal to a given value.
+        : arr.length == length
+        Params:
+            arr (uint[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthEqual(uint[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength == length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    /*
+        Function: lengthNotEqual(uint[])
+        Assert that the length of a 'uint[]' is not equal to a given value.
+        : arr.length != length
+        Params:
+            arr (uint[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthNotEqual(uint[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength != arr.length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    // ************************************** int[] **************************************
+
+    /*
+        Function: equal(int[])
+        Assert that two 'int[]' are equal.
+        : arrA.length == arrB.length
+        and, for all valid indices 'i'
+        : arrA[i] == arrB[i]
+        Params:
+            A (int[]) - The first array.
+            B (int[]) - The second array.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(int[] arrA, int[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        _report(result, message);
+    }
+
+    /*
+        Function: notEqual(int[])
+        Assert that two 'int[]' are not equal.
+        : arrA.length != arrB.length
+        or, for some valid index 'i'
+        : arrA[i] != arrB[i]
+        Params:
+            A (int[]) - The first string.
+            B (int[]) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(int[] arrA, int[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        result = !result;
+        _report(result, message);
+    }
+
+    /*
+        Function: lengthEqual(int[])
+        Assert that the length of an 'int[]' is equal to a given value.
+        : arr.length == length
+        Params:
+            arr (int[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthEqual(int[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength == length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    /*
+        Function: lengthNotEqual(int[])
+        Assert that the length of an 'int[]' is not equal to a given value.
+        : arr.length != length
+        Params:
+            arr (int[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthNotEqual(int[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength != arr.length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    // ************************************** address[] **************************************
+
+    /*
+        Function: equal(address[])
+        Assert that two 'address[]' are equal.
+        : arrA.length == arrB.length
+        and, for all valid indices 'i'
+        : arrA[i] == arrB[i]
+        Params:
+            A (address[]) - The first array.
+            B (address[]) - The second array.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(address[] arrA, address[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        _report(result, message);
+    }
+
+    /*
+        Function: notEqual(address[])
+        Assert that two 'address[]' are not equal.
+        : arrA.length != arrB.length
+        or, for some valid index 'i'
+        : arrA[i] != arrB[i]
+        Params:
+            A (address[]) - The first string.
+            B (address[]) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(address[] arrA, address[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        result = !result;
+        _report(result, message);
+    }
+
+    /*
+        Function: lengthEqual(address[])
+        Assert that the length of an 'address[]' is equal to a given value.
+        : arr.length == length
+        Params:
+            arr (address[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthEqual(address[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength == length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    /*
+        Function: lengthNotEqual(address[])
+        Assert that the length of an 'address[]' is not equal to a given value.
+        : arr.length != length
+        Params:
+            arr (address[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthNotEqual(address[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength != arr.length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    // ************************************** bytes32[] **************************************
+
+    /*
+        Function: equal(bytes32[])
+        Assert that two 'bytes32[]' are equal.
+        : arrA.length == arrB.length
+        and, for all valid indices 'i'
+        : arrA[i] == arrB[i]
+        Params:
+            A (bytes32[]) - The first array.
+            B (bytes32[]) - The second array.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function equal(bytes32[] arrA, bytes32[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        _report(result, message);
+    }
+
+    /*
+        Function: notEqual(bytes32[])
+        Assert that two 'bytes32[]' are not equal.
+        : arrA.length != arrB.length
+        or, for some valid index 'i'
+        : arrA[i] != arrB[i]
+        Params:
+            A (bytes32[]) - The first string.
+            B (bytes32[]) - The second string.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function notEqual(bytes32[] arrA, bytes32[] arrB, string message) public returns (bool result) {
+        result = arrA.length == arrB.length;
+        if (result) {
+            for (uint i = 0; i < arrA.length; i++) {
+                if (arrA[i] != arrB[i]) {
+                    result = false;
+                    break;
+                }
+            }
+        }
+        result = !result;
+        _report(result, message);
+    }
+
+    /*
+        Function: lengthEqual(bytes32[])
+        Assert that the length of an 'bytes32[]' is equal to a given value.
+        : arr.length == length
+        Params:
+            arr (bytes32[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthEqual(bytes32[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength == length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    /*
+        Function: lengthNotEqual(bytes32[])
+        Assert that the length of an 'bytes32[]' is not equal to a given value.
+        : arr.length != length
+        Params:
+            arr (bytes32[]) - The array.
+            length (uint) - The length.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function lengthNotEqual(bytes32[] arr, uint length, string message) public returns (bool result) {
+        uint arrLength = arr.length;
+        if (arrLength != arr.length)
+            _report(result, "");
+        else
+            _report(result, _appendTagged(_tag(arrLength, "Tested"), _tag(length, "Against"), message));
+    }
+
+    // ************************************** balances **************************************
+
+    /*
+        Function: balanceEqual
+        Assert that the balance of an account 'A' is equal to a given number 'b'.
+        : A.balance = b
+        Params:
+            A (address) - The first address.
+            b (uint) - The balance.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function balanceEqual(address a, uint b, string message) public returns (bool result) {
+        result = (a.balance == b);
+        _report(result, message);
+    }
+
+    /*
+        Function: balanceNotEqual
+        Assert that the balance of an account 'A' is not equal to a given number 'b'.
+        : A.balance != b
+        Params:
+            A (address) - The first address.
+            b (uint) - The balance.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function balanceNotEqual(address a, uint b, string message) public returns (bool result) {
+        result = (a.balance != b);
+        _report(result, message);
+    }
+
+    /*
+        Function: balanceIsZero
+        Assert that the balance of an account 'A' is zero.
+        : A.balance == 0
+        Params:
+            A (address) - The first address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function balanceIsZero(address a, string message) public returns (bool result) {
+        result = (a.balance == 0);
+        _report(result, message);
+    }
+
+    /*
+        Function: balanceIsNotZero
+        Assert that the balance of an account 'A' is not zero.
+        : A.balance != 0
+        Params:
+            A (address) - The first address.
+            message (string) - A message that is sent if the assertion fails.
+        Returns:
+            result (bool) - The result.
+    */
+    function balanceIsNotZero(address a, string message) public returns (bool result) {
+        result = (a.balance != 0);
+        _report(result, message);
+    }
+
+    /******************************** internal ********************************/
+
+        /*
+            Function: _report
+            Internal function for triggering <TestEvent>.
+            Params:
+                result (bool) - The test result (true or false).
+                message (string) - The message that is sent if the assertion fails.
+        */
+    function _report(bool result, string message) internal {
+        if(result)
+            emit TestEvent(true, "");
+        else
+            emit TestEvent(false, message);
+    }
+
+    /*
+        Function: _stringsEqual
+        Compares two strings. Taken from the StringUtils contract in the Ethereum Dapp-bin
+        (https://github.com/ethereum/dapp-bin/blob/master/library/stringUtils.sol).
+        Params:
+            a (string) - The first string.
+            b (string) - The second string.
+        Returns:
+             result (bool) - 'true' if the strings are equal, otherwise 'false'.
+    */
+    function _stringsEqual(string a, string b) internal pure returns (bool result) {
+        bytes memory ba = bytes(a);
+        bytes memory bb = bytes(b);
+
+        if (ba.length != bb.length)
+            return false;
+        for (uint i = 0; i < ba.length; i ++) {
+            if (ba[i] != bb[i])
+                return false;
+        }
+        return true;
+    }
+
+    /*
+        Function: _itoa
+        Convert a signed integer to a string. Negative numbers gets a '-' in front, e.g. "-54".
+        Params:
+            n (int) - The integer.
+            radix (uint8) - A number between 2 and 16 (inclusive). Characters used are 0-9,a-f
+        Returns:
+            result (string) - The resulting string.
+    */
+    function _itoa(int n, uint8 radix) internal pure returns (string) {
+        if (n == 0 || radix < 2 || radix > 16)
+            return '0';
+        bytes memory bts = new bytes(256);
+        uint i;
+        bool neg = false;
+        if (n < 0) {
+            n = -n;
+            neg = true;
+        }
+        while (n > 0) {
+            bts[i++] = _utoa(uint8(n % radix)); // Turn it to ascii.
+            n /= radix;
+        }
+        // Reverse
+        uint size = i;
+        uint j = 0;
+        bytes memory rev;
+        if (neg) {
+            size++;
+            j = 1;
+            rev = new bytes(size);
+            rev[0] = MINUS;
+        }
+        else
+            rev = new bytes(size);
+
+        for (; j < size; j++)
+            rev[j] = bts[size - j - 1];
+        return string(rev);
+    }
+
+    /*
+        Function: _utoa(uint)
+        Convert an  unsigned integer to a string.
+        Params:
+            n (uint) - The unsigned integer.
+            radix (uint8) - A number between 2 and 16 (inclusive). Characters used are 0-9,a-f
+        Returns:
+            result (string) - The resulting string.
+    */
+    function _utoa(uint n, uint8 radix) internal pure returns (string) {
+        if (n == 0 || radix < 2 || radix > 16)
+            return '0';
+        bytes memory bts = new bytes(256);
+        uint i;
+        while (n > 0) {
+            bts[i++] = _utoa(uint8(n % radix)); // Turn it to ascii.
+            n /= radix;
+        }
+        // Reverse
+        bytes memory rev = new bytes(i);
+        for (uint j = 0; j < i; j++)
+            rev[j] = bts[i - j - 1];
+        return string(rev);
+    }
+
+    /*
+        Function: _utoa(uint8)
+        Convert an unsigned 8-bit integer to its ASCII byte representation. Numbers 0-9 are converted to '0'-'9',
+        numbers 10-16 to 'a'-'f'. Numbers larger then 16 return the null byte.
+        Params:
+            u (uint8) - The unsigned 8-bit integer.
+        Returns:
+            result (string) - The ASCII byte.
+    */
+    function _utoa(uint8 u) internal pure returns (byte) {
+        if (u < 10)
+            return byte(u + ZERO);
+        else if (u < 16)
+            return byte(u - 10 + A);
+        else
+            return 0;
+    }
+
+    /*
+        Function: _ltoa
+        Convert an boolean to a string.
+        Params:
+            val (bool) - The boolean.
+        Returns:
+            result (string) - "true" if true, "false" if false.
+    */
+    function _ltoa(bool val) internal pure returns (string) {
+        bytes memory b;
+        if (val) {
+            b = new bytes(4);
+            b[0] = 't';
+            b[1] = 'r';
+            b[2] = 'u';
+            b[3] = 'e';
+            return string(b);
+        }
+        else {
+            b = new bytes(5);
+            b[0] = 'f';
+            b[1] = 'a';
+            b[2] = 'l';
+            b[3] = 's';
+            b[4] = 'e';
+            return string(b);
+        }
+    }
+
+    /*
+    function htoa(address addr) constant returns (string) {
+        bytes memory bts = new bytes(40);
+        bytes20 addrBts = bytes20(addr);
+        for (uint i = 0; i < 20; i++) {
+            bts[2*i] = addrBts[i] % 16;
+            bts[2*i + 1] = (addrBts[i] / 16) % 16;
+        }
+        return string(bts);
+    }
+    */
+
+    /*
+        Function: _tag(string)
+        Add a tag to a string. The 'value' and 'tag' strings are returned on the form "tag: value".
+        Params:
+            value (string) - The value.
+            tag (string) - The tag.
+        Returns:
+            result (string) - "tag: value"
+    */
+    function _tag(string value, string tag) internal pure returns (string) {
+
+        bytes memory valueB = bytes(value);
+        bytes memory tagB = bytes(tag);
+
+        uint vl = valueB.length;
+        uint tl = tagB.length;
+
+        bytes memory newB = new bytes(vl + tl + 2);
+
+        uint i;
+        uint j;
+
+        for (i = 0; i < tl; i++)
+            newB[j++] = tagB[i];
+        newB[j++] = ':';
+        newB[j++] = ' ';
+        for (i = 0; i < vl; i++)
+            newB[j++] = valueB[i];
+
+        return string(newB);
+    }
+
+    /*
+        Function: _tag(int)
+        Add a tag to an int.
+        Params:
+            value (int) - The value.
+            tag (string) - The tag.
+        Returns:
+            result (string) - "tag: _itoa(value)"
+    */
+    function _tag(int value, string tag) internal pure returns (string) {
+        string memory nstr = _itoa(value, 10);
+        return _tag(nstr, tag);
+    }
+
+    /*
+        Function: _tag(uint)
+        Add a tag to an uint.
+        Params:
+            value (uint) - The value.
+            tag (string) - The tag.
+        Returns:
+            result (string) - "tag: _utoa(value)"
+    */
+    function _tag(uint value, string tag) internal pure returns (string) {
+        string memory nstr = _utoa(value, 10);
+        return _tag(nstr, tag);
+    }
+
+    /*
+        Function: _tag(bool)
+        Add a tag to a boolean.
+        Params:
+            value (bool) - The value.
+            tag (string) - The tag.
+        Returns:
+            result (string) - "tag: _ltoa(value)"
+    */
+    function _tag(bool value, string tag) internal pure returns (string) {
+        string memory nstr = _ltoa(value);
+        return _tag(nstr, tag);
+    }
+
+    /*
+        Function: _appendTagged(string)
+        Append a tagged value to a string.
+        Params:
+            tagged (string) - The tagged value.
+            str (string) - The string.
+        Returns:
+            result (string) - "str (tagged)"
+    */
+    function _appendTagged(string tagged, string str) internal pure returns (string) {
+
+        bytes memory taggedB = bytes(tagged);
+        bytes memory strB = bytes(str);
+
+        uint sl = strB.length;
+        uint tl = taggedB.length;
+
+        bytes memory newB = new bytes(sl + tl + 3);
+
+        uint i;
+        uint j;
+
+        for (i = 0; i < sl; i++)
+            newB[j++] = strB[i];
+        newB[j++] = ' ';
+        newB[j++] = '(';
+        for (i = 0; i < tl; i++)
+            newB[j++] = taggedB[i];
+        newB[j++] = ')';
+
+        return string(newB);
+    }
+
+    /*
+        Function: _appendTagged(string, string)
+        Append two tagged values to a string.
+        Params:
+            tagged0 (string) - The first tagged value.
+            tagged1 (string) - The second tagged value.
+            str (string) - The string.
+        Returns:
+            result (string) - "str (tagged0, tagged1)"
+    */
+    function _appendTagged(string tagged0, string tagged1, string str) internal pure returns (string) {
+
+        bytes memory tagged0B = bytes(tagged0);
+        bytes memory tagged1B = bytes(tagged1);
+        bytes memory strB = bytes(str);
+
+        uint sl = strB.length;
+        uint t0l = tagged0B.length;
+        uint t1l = tagged1B.length;
+
+        bytes memory newB = new bytes(sl + t0l + t1l + 5);
+
+        uint i;
+        uint j;
+
+        for (i = 0; i < sl; i++)
+            newB[j++] = strB[i];
+        newB[j++] = ' ';
+        newB[j++] = '(';
+        for (i = 0; i < t0l; i++)
+            newB[j++] = tagged0B[i];
+        newB[j++] = ',';
+        newB[j++] = ' ';
+        for (i = 0; i < t1l; i++)
+            newB[j++] = tagged1B[i];
+        newB[j++] = ')';
+
+        return string(newB);
+    }
+
+}
diff --git a/node_modules/@aragon/os/contracts/test/helpers/EthSender.sol b/node_modules/@aragon/os/contracts/test/helpers/EthSender.sol
new file mode 100644
index 0000000..c9ee9e7
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/helpers/EthSender.sol
@@ -0,0 +1,8 @@
+pragma solidity 0.4.24;
+
+
+contract EthSender {
+    function sendEth(address to) external payable {
+        to.transfer(msg.value);
+    }
+}
\ No newline at end of file
diff --git a/node_modules/@aragon/os/contracts/test/helpers/ProxyTarget.sol b/node_modules/@aragon/os/contracts/test/helpers/ProxyTarget.sol
new file mode 100644
index 0000000..177fb65
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/helpers/ProxyTarget.sol
@@ -0,0 +1,17 @@
+pragma solidity 0.4.24;
+
+contract ProxyTargetWithoutFallback {
+    event Pong();
+
+    function ping() external {
+      emit Pong();
+    }
+}
+
+contract ProxyTargetWithFallback is ProxyTargetWithoutFallback {
+    event ReceivedEth();
+
+    function () external payable {
+      emit ReceivedEth();
+    }
+}
\ No newline at end of file
diff --git a/node_modules/@aragon/os/contracts/test/helpers/ThrowProxy.sol b/node_modules/@aragon/os/contracts/test/helpers/ThrowProxy.sol
new file mode 100644
index 0000000..f901046
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/helpers/ThrowProxy.sol
@@ -0,0 +1,33 @@
+pragma solidity ^0.4.24;
+
+import "./Assert.sol";
+
+// Based on Simon de la Rouviere method: http://truffleframework.com/tutorials/testing-for-throws-in-solidity-tests
+
+
+// Proxy contract for testing throws
+contract ThrowProxy {
+  address public target;
+  bytes data;
+
+  constructor(address _target) public {
+    target = _target;
+  }
+
+  //prime the data using the fallback function.
+  function() public {
+    data = msg.data;
+  }
+
+  function assertThrows(string _msg) public {
+    Assert.isFalse(execute(), _msg);
+  }
+
+  function assertItDoesntThrow(string _msg) public {
+    Assert.isTrue(execute(), _msg);
+  }
+
+  function execute() public returns (bool) {
+    return target.call(data);
+  }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apm/APMNamehashMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apm/APMNamehashMock.sol
new file mode 100644
index 0000000..f741d19
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apm/APMNamehashMock.sol
@@ -0,0 +1,12 @@
+pragma solidity 0.4.24;
+
+import "../../../apm/APMNamehash.sol";
+
+
+contract APMNamehashMock is APMNamehash {
+    function getAPMNode() external pure returns (bytes32) { return APM_NODE; }
+
+    function getAPMNamehash(string name) external pure returns (bytes32) {
+        return apmNamehash(name);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apm/UnsafeRepo.sol b/node_modules/@aragon/os/contracts/test/mocks/apm/UnsafeRepo.sol
new file mode 100644
index 0000000..129d67f
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apm/UnsafeRepo.sol
@@ -0,0 +1,13 @@
+pragma solidity 0.4.24;
+
+import "../../../apm/Repo.sol";
+import "../../../apps/UnsafeAragonApp.sol";
+
+
+// Allows Repo to be used without a proxy or access controls
+contract UnsafeRepo is Repo, UnsafeAragonApp {
+    // Protected actions are always performable
+    function canPerform(address, bytes32, uint256[]) public view returns (bool) {
+        return true;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppProxyPinnedStorageMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppProxyPinnedStorageMock.sol
new file mode 100644
index 0000000..1c4ea2a
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppProxyPinnedStorageMock.sol
@@ -0,0 +1,40 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AppProxyPinned.sol";
+import "../../../kernel/IKernel.sol";
+import "../../../kernel/Kernel.sol";
+
+
+contract FakeAppConstants {
+    bytes32 public constant FAKE_APP_ID = keccak256('FAKE_APP_ID');
+}
+
+contract KernelPinnedStorageMock is Kernel, FakeAppConstants {
+    constructor(address _fakeApp) Kernel(false) public {
+        _setApp(KERNEL_APP_BASES_NAMESPACE, FAKE_APP_ID, _fakeApp);
+    }
+}
+
+
+// Testing this contract is a bit of a pain... we can't overload anything to make the contract check
+// pass in the constructor, so we're forced to initialize this with a mocked Kernel that already
+// sets a contract for the fake app.
+contract AppProxyPinnedStorageMock is AppProxyPinned, FakeAppConstants {
+    constructor(KernelPinnedStorageMock _mockKernel)
+        AppProxyPinned(IKernel(_mockKernel), FAKE_APP_ID, new bytes(0))
+        public // solium-disable-line visibility-first
+    {
+    }
+
+    function setPinnedCodeExt(address _pinnedCode) public {
+        setPinnedCode(_pinnedCode);
+    }
+
+    function getPinnedCodePosition() public pure returns (bytes32) {
+        return PINNED_CODE_POSITION;
+    }
+
+    function pinnedCodeExt() public view returns (address) {
+        return pinnedCode();
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppStorageMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStorageMock.sol
new file mode 100644
index 0000000..4b7958d
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStorageMock.sol
@@ -0,0 +1,22 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AppStorage.sol";
+
+
+contract AppStorageMock is AppStorage {
+    function setKernelExt(IKernel _kernel) public {
+        setKernel(_kernel);
+    }
+
+    function setAppIdExt(bytes32 _appId) public {
+        setAppId(_appId);
+    }
+
+    function getKernelPosition() public pure returns (bytes32) {
+        return KERNEL_POSITION;
+    }
+
+    function getAppIdPosition() public pure returns (bytes32) {
+        return APP_ID_POSITION;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppStub.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStub.sol
new file mode 100644
index 0000000..78aca1a
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStub.sol
@@ -0,0 +1,48 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AragonApp.sol";
+import "../../../apps/UnsafeAragonApp.sol";
+import "../../../kernel/IKernel.sol";
+
+
+contract AppStubStorage {
+    uint a;
+    string public stringTest;
+}
+
+contract AppStub is AragonApp, AppStubStorage {
+    bytes32 public constant ROLE = keccak256("ROLE");
+
+    function initialize(uint256 epoch) onlyInit public {
+        initialized(epoch);
+        stringTest = "hola";
+    }
+
+    function requiresInitialization() isInitialized public constant returns (bool) {
+        return true;
+    }
+
+    function setValue(uint i) auth(ROLE) public {
+        a = i;
+    }
+
+    function setValueParam(uint i) authP(ROLE, arr(i)) public {
+        a = i;
+    }
+
+    function getValue() public constant returns (uint) {
+        return a;
+    }
+}
+
+contract AppStub2 is AragonApp, AppStubStorage {
+    function getValue() public constant returns (uint) {
+        return a * 2;
+    }
+}
+
+contract UnsafeAppStub is AppStub, UnsafeAragonApp {
+    constructor(IKernel _kernel) public {
+        setKernel(_kernel);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubConditionalRecovery.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubConditionalRecovery.sol
new file mode 100644
index 0000000..2f01b03
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubConditionalRecovery.sol
@@ -0,0 +1,17 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AragonApp.sol";
+import "../../../common/DepositableStorage.sol";
+
+
+contract AppStubConditionalRecovery is AragonApp, DepositableStorage {
+    function initialize(uint256 epoch) onlyInit public {
+        initialized(epoch);
+        setDepositable(true);
+    }
+
+    function allowRecoverability(address token) public view returns (bool) {
+        // Doesn't allow to recover ether
+        return token != address(0);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubDepositable.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubDepositable.sol
new file mode 100644
index 0000000..58de395
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubDepositable.sol
@@ -0,0 +1,26 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AragonApp.sol";
+import "../../../apps/UnsafeAragonApp.sol";
+import "../../../common/DepositableStorage.sol";
+
+
+contract AppStubDepositable is AragonApp, DepositableStorage {
+    function () external payable {
+        require(isDepositable());
+    }
+
+    function initialize(uint256 epoch) onlyInit public {
+        initialized(epoch);
+    }
+
+    function enableDeposits() external {
+        setDepositable(true);
+    }
+}
+
+contract UnsafeAppStubDepositable is AppStubDepositable, UnsafeAragonApp {
+    constructor(IKernel _kernel) public {
+        setKernel(_kernel);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubScriptRunner.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubScriptRunner.sol
new file mode 100644
index 0000000..9c12e29
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/AppStubScriptRunner.sol
@@ -0,0 +1,57 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/AragonApp.sol";
+
+
+contract AppStubScriptRunner is AragonApp {
+    event ReturnedBytes(bytes returnedBytes);
+
+    // Initialization is required to access any of the real executors
+    function initialize(uint256 epoch) public {
+        initialized(epoch);
+    }
+
+    function runScript(bytes script) public returns (bytes) {
+        bytes memory returnedBytes = runScript(script, new bytes(0), new address[](0));
+        emit ReturnedBytes(returnedBytes);
+        return returnedBytes;
+    }
+
+    function runScriptWithBan(bytes script, address[] memory blacklist) public returns (bytes) {
+        bytes memory returnedBytes = runScript(script, new bytes(0), blacklist);
+        emit ReturnedBytes(returnedBytes);
+        return returnedBytes;
+    }
+
+    function runScriptWithIO(bytes script, bytes input, address[] memory blacklist) public returns (bytes) {
+        bytes memory returnedBytes = runScript(script, input, blacklist);
+        emit ReturnedBytes(returnedBytes);
+        return returnedBytes;
+    }
+
+    function runScriptWithNewBytesAllocation(bytes script) public returns (bytes) {
+        bytes memory returnedBytes = runScript(script, new bytes(0), new address[](0));
+        bytes memory newBytes = new bytes(64);
+
+        // Fill in new bytes array with some dummy data to let us check it doesn't corrupt the
+        // script's returned bytes
+        uint256 first = uint256(keccak256("test"));
+        uint256 second = uint256(keccak256("mock"));
+        assembly {
+            mstore(add(newBytes, 0x20), first)
+            mstore(add(newBytes, 0x40), second)
+        }
+        emit ReturnedBytes(returnedBytes);
+        return returnedBytes;
+    }
+
+    /*
+    function getActionsCount(bytes script) public constant returns (uint256) {
+        return getScriptActionsCount(script);
+    }
+
+    function getAction(bytes script, uint256 i) public constant returns (address, bytes) {
+        return getScriptAction(script, i);
+    }
+    */
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/DepositableDelegateProxyMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/DepositableDelegateProxyMock.sol
new file mode 100644
index 0000000..c6365df
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/DepositableDelegateProxyMock.sol
@@ -0,0 +1,24 @@
+pragma solidity 0.4.24;
+
+import "../../../common/DepositableDelegateProxy.sol";
+
+
+contract DepositableDelegateProxyMock is DepositableDelegateProxy {
+    address private implementationMock;
+
+    function enableDepositsOnMock() external {
+        setDepositable(true);
+    }
+
+    function setImplementationOnMock(address _implementationMock) external {
+        implementationMock = _implementationMock;
+    }
+
+    function implementation() public view returns (address) {
+        return implementationMock;
+    }
+
+    function proxyType() public pure returns (uint256 proxyTypeId) {
+        return UPGRADEABLE;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/UnsafeAragonAppMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/UnsafeAragonAppMock.sol
new file mode 100644
index 0000000..2af8156
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/UnsafeAragonAppMock.sol
@@ -0,0 +1,19 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/UnsafeAragonApp.sol";
+import "../../../kernel/IKernel.sol";
+
+
+contract UnsafeAragonAppMock is UnsafeAragonApp {
+    function initialize(uint256 epoch) public {
+        initialized(epoch);
+    }
+
+    function getKernel() public view returns (IKernel) {
+        return kernel();
+    }
+
+    function setKernelOnMock(IKernel _kernel) public {
+        setKernel(_kernel);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/apps/VaultMock.sol b/node_modules/@aragon/os/contracts/test/mocks/apps/VaultMock.sol
new file mode 100644
index 0000000..0ae9885
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/apps/VaultMock.sol
@@ -0,0 +1,18 @@
+pragma solidity 0.4.24;
+
+import "../../../apps/UnsafeAragonApp.sol";
+import "../../../common/DepositableStorage.sol";
+
+
+contract VaultMock is UnsafeAragonApp, DepositableStorage {
+    event LogFund(address sender, uint256 amount);
+
+    function initialize(uint256 epoch) external {
+        initialized(epoch);
+        setDepositable(true);
+    }
+
+    function () external payable {
+        emit LogFund(msg.sender, msg.value);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/DepositableStorageMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/DepositableStorageMock.sol
new file mode 100644
index 0000000..56f190a
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/DepositableStorageMock.sol
@@ -0,0 +1,14 @@
+pragma solidity 0.4.24;
+
+import "../../../common/DepositableStorage.sol";
+
+
+contract DepositableStorageMock is DepositableStorage {
+    function setDepositableExt(bool _depositable) public {
+        setDepositable(_depositable);
+    }
+
+    function getDepositablePosition() public pure returns (bytes32) {
+        return DEPOSITABLE_POSITION;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/EtherTokenConstantMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/EtherTokenConstantMock.sol
new file mode 100644
index 0000000..0c7e827
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/EtherTokenConstantMock.sol
@@ -0,0 +1,8 @@
+pragma solidity 0.4.24;
+
+import "../../../common/EtherTokenConstant.sol";
+
+
+contract EtherTokenConstantMock is EtherTokenConstant {
+    function getETHConstant() external pure returns (address) { return ETH; }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/InitializableStorageMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/InitializableStorageMock.sol
new file mode 100644
index 0000000..8deae3e
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/InitializableStorageMock.sol
@@ -0,0 +1,14 @@
+pragma solidity 0.4.24;
+
+import "../../../common/Initializable.sol";
+
+
+contract InitializableStorageMock is Initializable {
+    function initialize(uint256 epoch) onlyInit public {
+        initialized(epoch);
+    }
+
+    function getInitializationBlockPosition() public pure returns (bytes32) {
+        return INITIALIZATION_BLOCK_POSITION;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/KeccakConstants.sol b/node_modules/@aragon/os/contracts/test/mocks/common/KeccakConstants.sol
new file mode 100644
index 0000000..6cc9a5b
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/KeccakConstants.sol
@@ -0,0 +1,56 @@
+pragma solidity 0.4.24;
+
+
+contract KeccakConstants {
+    // ENS
+    bytes32 public constant ENS_ROOT = bytes32(0);
+    bytes32 public constant ETH_TLD_LABEL = keccak256(abi.encodePacked("eth"));
+    bytes32 public constant ETH_TLD_NODE = keccak256(abi.encodePacked(ENS_ROOT, ETH_TLD_LABEL));
+    bytes32 public constant PUBLIC_RESOLVER_LABEL = keccak256(abi.encodePacked("resolver"));
+    bytes32 public constant PUBLIC_RESOLVER_NODE = keccak256(abi.encodePacked(ETH_TLD_NODE, PUBLIC_RESOLVER_LABEL));
+
+    // APM
+    bytes32 public constant APM_NODE = keccak256(abi.encodePacked(ETH_TLD_NODE, keccak256(abi.encodePacked("aragonpm"))));
+
+    // Kernel
+    bytes32 public constant KERNEL_CORE_NAMESPACE = keccak256(abi.encodePacked("core"));
+    bytes32 public constant KERNEL_APP_BASES_NAMESPACE = keccak256(abi.encodePacked("base"));
+    bytes32 public constant KERNEL_APP_ADDR_NAMESPACE = keccak256(abi.encodePacked("app"));
+
+    bytes32 public constant APP_MANAGER_ROLE = keccak256(abi.encodePacked("APP_MANAGER_ROLE"));
+
+    bytes32 public constant KERNEL_APP_ID = keccak256(abi.encodePacked(APM_NODE, keccak256("kernel")));
+    bytes32 public constant DEFAULT_ACL_APP_ID = keccak256(abi.encodePacked(APM_NODE, keccak256("acl")));
+    bytes32 public constant DEFAULT_VAULT_APP_ID = keccak256(abi.encodePacked(APM_NODE, keccak256("vault")));
+
+    // ACL
+    bytes32 public constant CREATE_PERMISSIONS_ROLE = keccak256(abi.encodePacked("CREATE_PERMISSIONS_ROLE"));
+    bytes32 public constant EMPTY_PARAM_HASH = keccak256(abi.encodePacked(uint256(0)));
+
+    // APMRegistry
+    bytes32 public constant CREATE_REPO_ROLE = keccak256(abi.encodePacked("CREATE_REPO_ROLE"));
+
+    // ENSSubdomainRegistrar
+    bytes32 public constant CREATE_NAME_ROLE = keccak256(abi.encodePacked("CREATE_NAME_ROLE"));
+    bytes32 public constant DELETE_NAME_ROLE = keccak256(abi.encodePacked("DELETE_NAME_ROLE"));
+    bytes32 public constant POINT_ROOTNODE_ROLE = keccak256(abi.encodePacked("POINT_ROOTNODE_ROLE"));
+
+    // EVMScriptRegistry
+    bytes32 public constant EVMSCRIPT_REGISTRY_APP_ID = keccak256(abi.encodePacked(APM_NODE, keccak256("evmreg")));
+    bytes32 public constant REGISTRY_ADD_EXECUTOR_ROLE = keccak256("REGISTRY_ADD_EXECUTOR_ROLE");
+    bytes32 public constant REGISTRY_MANAGER_ROLE = keccak256(abi.encodePacked("REGISTRY_MANAGER_ROLE"));
+
+    // EVMScriptExecutor types
+    bytes32 public constant EVMSCRIPT_EXECUTOR_CALLS_SCRIPT = keccak256(abi.encodePacked("CALLS_SCRIPT"));
+
+    // Repo
+    bytes32 public constant CREATE_VERSION_ROLE = keccak256(abi.encodePacked("CREATE_VERSION_ROLE"));
+
+    // Unstructured storage
+    bytes32 public constant initializationBlockPosition = keccak256(abi.encodePacked("aragonOS.initializable.initializationBlock"));
+    bytes32 public constant depositablePosition = keccak256(abi.encodePacked("aragonOS.depositableStorage.depositable"));
+    bytes32 public constant reentrancyGuardPosition = keccak256(abi.encodePacked("aragonOS.reentrancyGuard.mutex"));
+    bytes32 public constant kernelPosition = keccak256(abi.encodePacked("aragonOS.appStorage.kernel"));
+    bytes32 public constant appIdPosition = keccak256(abi.encodePacked("aragonOS.appStorage.appId"));
+    bytes32 public constant pinnedCodePosition = keccak256(abi.encodePacked("aragonOS.appStorage.pinnedCode"));
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/LifecycleMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/LifecycleMock.sol
new file mode 100644
index 0000000..9e1d268
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/LifecycleMock.sol
@@ -0,0 +1,15 @@
+pragma solidity 0.4.24;
+
+import "../../../common/Initializable.sol";
+import "../../../common/Petrifiable.sol";
+
+
+contract LifecycleMock is Initializable, Petrifiable {
+    function initializeMock(uint256 epoch) public {
+        initialized(epoch);
+    }
+
+    function petrifyMock() public {
+        petrify();
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/ReentrancyGuardMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/ReentrancyGuardMock.sol
new file mode 100644
index 0000000..84568b9
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/ReentrancyGuardMock.sol
@@ -0,0 +1,53 @@
+pragma solidity 0.4.24;
+
+import "../../../common/ReentrancyGuard.sol";
+import "../../../common/UnstructuredStorage.sol";
+
+
+contract ReentrantActor {
+    bool reenterNonReentrant;
+
+    constructor(bool _reenterNonReentrant) public {
+        reenterNonReentrant = _reenterNonReentrant;
+    }
+
+    function reenter(ReentrancyGuardMock _mock) public {
+        // Set the reentrancy target to 0 so we don't infinite loop
+        ReentrantActor reentrancyTarget = ReentrantActor(0);
+
+        if (reenterNonReentrant) {
+            _mock.nonReentrantCall(reentrancyTarget);
+        } else {
+            _mock.reentrantCall(reentrancyTarget);
+        }
+    }
+}
+
+
+contract ReentrancyGuardMock is ReentrancyGuard {
+    using UnstructuredStorage for bytes32;
+
+    uint256 public callCounter;
+
+    function nonReentrantCall(ReentrantActor _target) public nonReentrant {
+        callCounter++;
+        if (_target != address(0)) {
+            _target.reenter(this);
+        }
+    }
+
+    function reentrantCall(ReentrantActor _target) public {
+        callCounter++;
+        if (_target != address(0)) {
+            _target.reenter(this);
+        }
+    }
+
+    function setReentrancyMutex(bool _mutex) public {
+        getReentrancyMutexPosition().setStorageBool(_mutex);
+    }
+
+    function getReentrancyMutexPosition() public pure returns (bytes32) {
+        return keccak256("aragonOS.reentrancyGuard.mutex");
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/TimeHelpersMock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/TimeHelpersMock.sol
new file mode 100644
index 0000000..af3894a
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/TimeHelpersMock.sol
@@ -0,0 +1,30 @@
+pragma solidity 0.4.24;
+
+import "../../../common/TimeHelpers.sol";
+
+
+contract TimeHelpersMock is TimeHelpers {
+    function getBlockNumberDirect() public view returns (uint256) {
+        return block.number;
+    }
+
+    function getBlockNumberExt() public view returns (uint256) {
+        return getBlockNumber();
+    }
+
+    function getBlockNumber64Ext() public view returns (uint64) {
+        return getBlockNumber64();
+    }
+
+    function getTimestampDirect() public view returns (uint256) {
+        return now;
+    }
+
+    function getTimestampExt() public view returns (uint256) {
+        return getTimestamp();
+    }
+
+    function getTimestamp64Ext() public view returns (uint64) {
+        return getTimestamp64();
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/common/Uint256Mock.sol b/node_modules/@aragon/os/contracts/test/mocks/common/Uint256Mock.sol
new file mode 100644
index 0000000..b323c64
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/common/Uint256Mock.sol
@@ -0,0 +1,12 @@
+pragma solidity 0.4.24;
+
+import "../../../common/Uint256Helpers.sol";
+
+
+contract Uint256Mock {
+    using Uint256Helpers for uint256;
+
+    function convert(uint256 a) public pure returns (uint64) {
+        return a.toUint64();
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/ens/ENSConstantsMock.sol b/node_modules/@aragon/os/contracts/test/mocks/ens/ENSConstantsMock.sol
new file mode 100644
index 0000000..2c33a35
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/ens/ENSConstantsMock.sol
@@ -0,0 +1,12 @@
+pragma solidity 0.4.24;
+
+import "../../../ens/ENSConstants.sol";
+
+
+contract ENSConstantsMock is ENSConstants {
+    function getEnsRoot() external pure returns (bytes32) { return ENS_ROOT; }
+    function getEthTldLabel() external pure returns (bytes32) { return ETH_TLD_LABEL; }
+    function getEthTldNode() external pure returns (bytes32) { return ETH_TLD_NODE; }
+    function getPublicResolverLabel() external pure returns (bytes32) { return PUBLIC_RESOLVER_LABEL; }
+    function getPublicResolverNode() external pure returns (bytes32) { return PUBLIC_RESOLVER_NODE; }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorMock.sol b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorMock.sol
new file mode 100644
index 0000000..8ccbd22
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorMock.sol
@@ -0,0 +1,20 @@
+pragma solidity 0.4.24;
+
+
+import "../../../evmscript/executors/BaseEVMScriptExecutor.sol";
+
+contract EVMScriptExecutorMock is BaseEVMScriptExecutor {
+    bytes32 internal constant EXECUTOR_TYPE = keccak256("MOCK_SCRIPT");
+
+    function execScript(bytes _script, bytes, address[]) external isInitialized returns (bytes) {
+        // Return full input script if it's more than just the spec ID, otherwise return an empty
+        // bytes array
+        if (_script.length > SCRIPT_START_LOCATION) {
+            return _script;
+        }
+    }
+
+    function executorType() external pure returns (bytes32) {
+        return EXECUTOR_TYPE;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorNoReturnMock.sol b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorNoReturnMock.sol
new file mode 100644
index 0000000..81876dc
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorNoReturnMock.sol
@@ -0,0 +1,18 @@
+pragma solidity 0.4.24;
+
+
+import "../../../evmscript/executors/BaseEVMScriptExecutor.sol";
+
+contract EVMScriptExecutorNoReturnMock is BaseEVMScriptExecutor {
+    bytes32 internal constant EXECUTOR_TYPE = keccak256("NO_RETURN_SCRIPT");
+
+    function execScript(bytes, bytes, address[]) external isInitialized returns (bytes) {
+        assembly {
+            stop
+        }
+    }
+
+    function executorType() external pure returns (bytes32) {
+        return EXECUTOR_TYPE;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorRevertMock.sol b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorRevertMock.sol
new file mode 100644
index 0000000..22e075f
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptExecutorRevertMock.sol
@@ -0,0 +1,17 @@
+pragma solidity 0.4.24;
+
+
+import "../../../evmscript/executors/BaseEVMScriptExecutor.sol";
+
+contract EVMScriptExecutorRevertMock is BaseEVMScriptExecutor {
+    string public constant ERROR_MOCK_REVERT = "MOCK_REVERT";
+    bytes32 internal constant EXECUTOR_TYPE = keccak256("MOCK_REVERT_SCRIPT");
+
+    function execScript(bytes, bytes, address[]) external isInitialized returns (bytes) {
+        revert(ERROR_MOCK_REVERT);
+    }
+
+    function executorType() external pure returns (bytes32) {
+        return EXECUTOR_TYPE;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptRegistryConstantsMock.sol b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptRegistryConstantsMock.sol
new file mode 100644
index 0000000..4ca8dfb
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/evmscript/EVMScriptRegistryConstantsMock.sol
@@ -0,0 +1,8 @@
+pragma solidity 0.4.24;
+
+import "../../../evmscript/IEVMScriptRegistry.sol";
+
+
+contract EVMScriptRegistryConstantsMock is EVMScriptRegistryConstants {
+    function getEVMScriptRegistryAppId() external pure returns (bytes32) { return EVMSCRIPT_REGISTRY_APP_ID; }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/evmscript/ExecutionTarget.sol b/node_modules/@aragon/os/contracts/test/mocks/evmscript/ExecutionTarget.sol
new file mode 100644
index 0000000..55c41a1
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/evmscript/ExecutionTarget.sol
@@ -0,0 +1,26 @@
+pragma solidity 0.4.24;
+
+
+contract ExecutionTarget {
+    string public constant ERROR_EXECUTION_TARGET = "EXECUTION_TARGET_REVERTED";
+    uint public counter;
+
+    function execute() public {
+        counter += 1;
+        emit Executed(counter);
+    }
+
+    function failExecute(bool errorWithData) public pure {
+        if (errorWithData) {
+            revert(ERROR_EXECUTION_TARGET);
+        } else {
+            revert();
+        }
+    }
+
+    function setCounter(uint x) public {
+        counter = x;
+    }
+
+    event Executed(uint x);
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/factory/APMRegistryFactoryMock.sol b/node_modules/@aragon/os/contracts/test/mocks/factory/APMRegistryFactoryMock.sol
new file mode 100644
index 0000000..c209aae
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/factory/APMRegistryFactoryMock.sol
@@ -0,0 +1,99 @@
+pragma solidity 0.4.24;
+
+import "../../../apm/APMRegistry.sol";
+import "../../../apm/Repo.sol";
+import "../../../ens/ENSSubdomainRegistrar.sol";
+
+import "../../../factory/DAOFactory.sol";
+import "../../../factory/ENSFactory.sol";
+
+// Mock that doesn't grant enough permissions
+// Only usable with new ENS instance
+
+contract APMRegistryFactoryMock is APMInternalAppNames {
+    DAOFactory public daoFactory;
+    APMRegistry public registryBase;
+    Repo public repoBase;
+    ENSSubdomainRegistrar public ensSubdomainRegistrarBase;
+    ENS public ens;
+
+    constructor(
+        DAOFactory _daoFactory,
+        APMRegistry _registryBase,
+        Repo _repoBase,
+        ENSSubdomainRegistrar _ensSubBase,
+        ENSFactory _ensFactory
+    ) public
+    {
+        daoFactory = _daoFactory;
+        registryBase = _registryBase;
+        repoBase = _repoBase;
+        ensSubdomainRegistrarBase = _ensSubBase;
+        ens = _ensFactory.newENS(this);
+    }
+
+    function newFailingAPM(
+        bytes32 _tld,
+        bytes32 _label,
+        address _root,
+        bool _withoutNameRole,
+        uint256 epoch
+    )
+        public
+        returns (APMRegistry)
+    {
+        // Set up ENS control
+        bytes32 node = keccak256(abi.encodePacked(_tld, _label));
+        ens.setSubnodeOwner(_tld, _label, this);
+
+        Kernel dao = daoFactory.newDAO(this, epoch);
+        ACL acl = ACL(dao.acl());
+
+        acl.createPermission(this, dao, dao.APP_MANAGER_ROLE(), this);
+
+        // Deploy app proxies
+        // bytes memory noInit = new bytes(0);
+        ENSSubdomainRegistrar ensSub = ENSSubdomainRegistrar(
+            dao.newAppInstance(
+                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(ENS_SUB_APP_NAME)))),
+                ensSubdomainRegistrarBase,
+                new bytes(0), // noInit
+                false
+            )
+        );
+        APMRegistry apm = APMRegistry(
+            dao.newAppInstance(
+                keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(APM_APP_NAME)))),
+                registryBase,
+                new bytes(0), // noInit
+                false
+            )
+        );
+
+        // APMRegistry controls Repos
+        bytes32 repoAppId = keccak256(abi.encodePacked(node, keccak256(abi.encodePacked(REPO_APP_NAME))));
+        dao.setApp(dao.APP_BASES_NAMESPACE(), repoAppId, repoBase);
+
+        // Grant permissions needed for APM on ENSSubdomainRegistrar
+        acl.createPermission(apm, ensSub, ensSub.POINT_ROOTNODE_ROLE(), _root);
+
+        // Don't grant all permissions needed for APM to initialize
+        if (_withoutNameRole) {
+            acl.createPermission(apm, ensSub, ensSub.CREATE_NAME_ROLE(), _root);
+        }
+
+        if (!_withoutNameRole) {
+            bytes32 permRole = acl.CREATE_PERMISSIONS_ROLE();
+            acl.grantPermission(apm, acl, permRole);
+        }
+
+        // Initialize
+        ens.setOwner(node, ensSub);
+        ensSub.initialize(ens, node, epoch);
+
+        // This should fail since we haven't given all required permissions
+        apm.initialize(ensSub, epoch);
+
+        return apm;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelConstantsMock.sol b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelConstantsMock.sol
new file mode 100644
index 0000000..47c6348
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelConstantsMock.sol
@@ -0,0 +1,15 @@
+pragma solidity 0.4.24;
+
+import "../../../kernel/Kernel.sol";
+
+
+contract KernelConstantsMock is Kernel {
+    constructor() public Kernel(false) { }
+
+    function getKernelCoreNamespace() external pure returns (bytes32) { return KERNEL_CORE_NAMESPACE; }
+    function getKernelAppBasesNamespace() external pure returns (bytes32) { return KERNEL_APP_BASES_NAMESPACE; }
+    function getKernelAppAddrNamespace() external pure returns (bytes32) { return KERNEL_APP_ADDR_NAMESPACE; }
+    function getKernelAppId() external pure returns (bytes32) { return KERNEL_CORE_APP_ID; }
+    function getDefaultACLAppId() external pure returns (bytes32) { return KERNEL_DEFAULT_ACL_APP_ID; }
+    function getDefaultVaultAppId() external pure returns (bytes32) { return KERNEL_DEFAULT_VAULT_APP_ID; }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelDepositableMock.sol b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelDepositableMock.sol
new file mode 100644
index 0000000..4de98fb
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelDepositableMock.sol
@@ -0,0 +1,17 @@
+pragma solidity 0.4.24;
+
+import "../../../common/DepositableStorage.sol";
+import "../../../kernel/Kernel.sol";
+
+contract KernelDepositableMock is Kernel, DepositableStorage {
+    constructor(bool _shouldPetrify) Kernel(_shouldPetrify) public {
+    }
+
+    function () external payable {
+        require(isDepositable());
+    }
+
+    function enableDeposits() external isInitialized {
+        setDepositable(true);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelOverloadMock.sol b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelOverloadMock.sol
new file mode 100644
index 0000000..66d87ec
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelOverloadMock.sol
@@ -0,0 +1,50 @@
+pragma solidity 0.4.24;
+
+import "../../../kernel/Kernel.sol";
+import "../../../lib/misc/ERCProxy.sol";
+
+
+/** Ugly hack to work around this issue:
+ * https://github.com/trufflesuite/truffle/issues/569
+ * https://github.com/trufflesuite/truffle/issues/737
+ *
+ * NOTE: awkwardly, by default we have access to the full version of `newAppInstance()` but only the
+ * minimized version for `newPinnedAppInstance()`
+ */
+contract KernelOverloadMock {
+    Kernel public kernel;
+
+    event NewAppProxy(address proxy);
+
+    constructor(Kernel _kernel) public {
+        kernel = _kernel;
+    }
+
+    /*
+    function newAppInstance(bytes32 _appId, address _appBase)
+        public
+        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))
+        returns (ERCProxy appProxy)
+    */
+    function newAppInstance(bytes32 _appId, address _appBase)
+        public
+        returns (ERCProxy appProxy)
+    {
+        appProxy = kernel.newAppInstance(_appId, _appBase);
+        emit NewAppProxy(appProxy);
+    }
+
+    /*
+    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)
+        public
+        auth(APP_MANAGER_ROLE, arr(KERNEL_APP_BASES_NAMESPACE, _appId))
+        returns (ERCProxy appProxy)
+    */
+    function newPinnedAppInstance(bytes32 _appId, address _appBase, bytes _initializePayload, bool _setDefault)
+        public
+        returns (ERCProxy appProxy)
+    {
+        appProxy = kernel.newPinnedAppInstance(_appId, _appBase, _initializePayload, _setDefault);
+        emit NewAppProxy(appProxy);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelSetAppMock.sol b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelSetAppMock.sol
new file mode 100644
index 0000000..2b91a64
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/kernel/KernelSetAppMock.sol
@@ -0,0 +1,13 @@
+pragma solidity 0.4.24;
+
+import "../../../kernel/Kernel.sol";
+
+contract KernelSetAppMock is Kernel {
+    constructor() Kernel(false) public {
+    }
+
+    // Overloaded mock to bypass the auth and isContract checks
+    function setApp(bytes32 _namespace, bytes32 _appId, address _app) public {
+        apps[_namespace][_appId] = _app;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/kernel/UpgradedKernel.sol b/node_modules/@aragon/os/contracts/test/mocks/kernel/UpgradedKernel.sol
new file mode 100644
index 0000000..2f84bc8
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/kernel/UpgradedKernel.sol
@@ -0,0 +1,14 @@
+pragma solidity 0.4.24;
+
+import "../../../kernel/Kernel.sol";
+
+
+contract UpgradedKernel is Kernel {
+    constructor(bool _shouldPetrify) Kernel(_shouldPetrify) public {}
+
+    // just adds one more function to the kernel implementation.
+    // calling this function on the previous instance will fail
+    function isUpgraded() public pure returns (bool) {
+        return true;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath64Mock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath64Mock.sol
new file mode 100644
index 0000000..de3bed0
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath64Mock.sol
@@ -0,0 +1,28 @@
+pragma solidity 0.4.24;
+
+import "../../../../lib/math/SafeMath64.sol";
+
+
+contract SafeMath64Mock {
+    using SafeMath64 for uint64;
+
+    function mulExt(uint64 _a, uint64 _b) public pure returns (uint64) {
+        return _a.mul(_b);
+    }
+
+    function divExt(uint64 _a, uint64 _b) public pure returns (uint64) {
+        return _a.div(_b);
+    }
+
+    function subExt(uint64 _a, uint64 _b) public pure returns (uint64) {
+        return _a.sub(_b);
+    }
+
+    function addExt(uint64 _a, uint64 _b) public pure returns (uint64) {
+        return _a.add(_b);
+    }
+
+    function modExt(uint64 _a, uint64 _b) public pure returns (uint64) {
+        return _a.mod(_b);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath8Mock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath8Mock.sol
new file mode 100644
index 0000000..df22aeb
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/math/SafeMath8Mock.sol
@@ -0,0 +1,28 @@
+pragma solidity 0.4.24;
+
+import "../../../../lib/math/SafeMath8.sol";
+
+
+contract SafeMath8Mock {
+    using SafeMath8 for uint8;
+
+    function mulExt(uint8 _a, uint8 _b) public pure returns (uint8) {
+        return _a.mul(_b);
+    }
+
+    function divExt(uint8 _a, uint8 _b) public pure returns (uint8) {
+        return _a.div(_b);
+    }
+
+    function subExt(uint8 _a, uint8 _b) public pure returns (uint8) {
+        return _a.sub(_b);
+    }
+
+    function addExt(uint8 _a, uint8 _b) public pure returns (uint8) {
+        return _a.add(_b);
+    }
+
+    function modExt(uint8 _a, uint8 _b) public pure returns (uint8) {
+        return _a.mod(_b);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/misc/ERCProxyMock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/misc/ERCProxyMock.sol
new file mode 100644
index 0000000..a85da5f
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/misc/ERCProxyMock.sol
@@ -0,0 +1,17 @@
+pragma solidity 0.4.24;
+
+import "../../../../lib/misc/ERCProxy.sol";
+
+
+contract ERCProxyMock is ERCProxy {
+    uint256 public constant FORWARDING = 1;
+    uint256 public constant UPGRADEABLE = 2;
+
+    function proxyType() public pure returns (uint256 proxyTypeId) {
+        return 0;
+    }
+
+    function implementation() public view returns (address codeAddr) {
+        return address(0);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/token/SafeERC20Mock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/token/SafeERC20Mock.sol
new file mode 100644
index 0000000..d1f8336
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/token/SafeERC20Mock.sol
@@ -0,0 +1,40 @@
+pragma solidity 0.4.24;
+
+import "../../../../common/SafeERC20.sol";
+import "../../../../lib/token/ERC20.sol";
+
+
+contract SafeERC20Mock {
+    using SafeERC20 for ERC20;
+    event Result(bool result);
+
+    function transfer(ERC20 token, address to, uint256 amount) external returns (bool) {
+        bool result = token.safeTransfer(to, amount);
+        emit Result(result);
+        return result;
+    }
+
+    function transferFrom(ERC20 token, address from, address to, uint256 amount) external returns (bool) {
+        bool result = token.safeTransferFrom(from, to, amount);
+        emit Result(result);
+        return result;
+    }
+
+    function approve(ERC20 token, address spender, uint256 amount) external returns (bool) {
+        bool result = token.safeApprove(spender, amount);
+        emit Result(result);
+        return result;
+    }
+
+    function allowance(ERC20 token, address owner, address spender) external view returns (uint256) {
+        return token.staticAllowance(owner, spender);
+    }
+
+    function balanceOf(ERC20 token, address owner) external view returns (uint256) {
+        return token.staticBalanceOf(owner);
+    }
+
+    function totalSupply(ERC20 token) external view returns (uint256) {
+        return token.staticTotalSupply();
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenMock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenMock.sol
new file mode 100644
index 0000000..8d51744
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenMock.sol
@@ -0,0 +1,106 @@
+// Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/StandardToken.sol
+
+pragma solidity 0.4.24;
+
+import "../../../../lib/math/SafeMath.sol";
+
+
+contract TokenMock {
+    using SafeMath for uint256;
+    mapping (address => uint256) private balances;
+    mapping (address => mapping (address => uint256)) private allowed;
+    uint256 private totalSupply_;
+    bool private allowTransfer_;
+
+    event Approval(address indexed owner, address indexed spender, uint256 value);
+    event Transfer(address indexed from, address indexed to, uint256 value);
+
+    // Allow us to set the inital balance for an account on construction
+    constructor(address initialAccount, uint256 initialBalance) public {
+        balances[initialAccount] = initialBalance;
+        totalSupply_ = initialBalance;
+        allowTransfer_ = true;
+    }
+
+    function totalSupply() public view returns (uint256) { return totalSupply_; }
+
+    /**
+    * @dev Gets the balance of the specified address.
+    * @param _owner The address to query the the balance of.
+    * @return An uint256 representing the amount owned by the passed address.
+    */
+    function balanceOf(address _owner) public view returns (uint256) {
+        return balances[_owner];
+    }
+
+    /**
+    * @dev Function to check the amount of tokens that an owner allowed to a spender.
+    * @param _owner address The address which owns the funds.
+    * @param _spender address The address which will spend the funds.
+    * @return A uint256 specifying the amount of tokens still available for the spender.
+    */
+    function allowance(address _owner, address _spender) public view returns (uint256) {
+        return allowed[_owner][_spender];
+    }
+
+    /**
+    * @dev Set whether the token is transferable or not
+    * @param _allowTransfer Should token be transferable
+    */
+    function setAllowTransfer(bool _allowTransfer) public {
+        allowTransfer_ = _allowTransfer;
+    }
+
+    /**
+    * @dev Transfer token for a specified address
+    * @param _to The address to transfer to.
+    * @param _value The amount to be transferred.
+    */
+    function transfer(address _to, uint256 _value) public returns (bool) {
+        require(allowTransfer_);
+        require(_value <= balances[msg.sender]);
+        require(_to != address(0));
+
+        balances[msg.sender] = balances[msg.sender].sub(_value);
+        balances[_to] = balances[_to].add(_value);
+        emit Transfer(msg.sender, _to, _value);
+        return true;
+    }
+
+    /**
+    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
+    * Beware that changing an allowance with this method brings the risk that someone may use both the old
+    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
+    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
+    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+    * @param _spender The address which will spend the funds.
+    * @param _value The amount of tokens to be spent.
+    */
+    function approve(address _spender, uint256 _value) public returns (bool) {
+        // Assume we want to protect for the race condition
+        require(allowed[msg.sender][_spender] == 0);
+
+        allowed[msg.sender][_spender] = _value;
+        emit Approval(msg.sender, _spender, _value);
+        return true;
+    }
+
+    /**
+    * @dev Transfer tokens from one address to another
+    * @param _from address The address which you want to send tokens from
+    * @param _to address The address which you want to transfer to
+    * @param _value uint256 the amount of tokens to be transferred
+    */
+    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
+        require(allowTransfer_);
+        require(_value <= balances[_from]);
+        require(_value <= allowed[_from][msg.sender]);
+        require(_to != address(0));
+
+        balances[_from] = balances[_from].sub(_value);
+        balances[_to] = balances[_to].add(_value);
+        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
+        emit Transfer(_from, _to, _value);
+        return true;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnFalseMock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnFalseMock.sol
new file mode 100644
index 0000000..6011fc0
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnFalseMock.sol
@@ -0,0 +1,110 @@
+// Standards compliant token that is returns false instead of reverting for
+// `transfer()`, `transferFrom()`, and `approve().
+// Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/StandardToken.sol
+
+pragma solidity 0.4.24;
+
+
+contract TokenReturnFalseMock {
+    mapping (address => uint256) private balances;
+    mapping (address => mapping (address => uint256)) private allowed;
+    uint256 private totalSupply_;
+    bool private allowTransfer_;
+
+    event Approval(address indexed owner, address indexed spender, uint256 value);
+    event Transfer(address indexed from, address indexed to, uint256 value);
+
+    // Allow us to set the inital balance for an account on construction
+    constructor(address initialAccount, uint256 initialBalance) public {
+        balances[initialAccount] = initialBalance;
+        totalSupply_ = initialBalance;
+        allowTransfer_ = true;
+    }
+
+    function totalSupply() public view returns (uint256) { return totalSupply_; }
+
+    /**
+    * @dev Gets the balance of the specified address.
+    * @param _owner The address to query the the balance of.
+    * @return An uint256 representing the amount owned by the passed address.
+    */
+    function balanceOf(address _owner) public view returns (uint256) {
+        return balances[_owner];
+    }
+
+    /**
+    * @dev Function to check the amount of tokens that an owner allowed to a spender.
+    * @param _owner address The address which owns the funds.
+    * @param _spender address The address which will spend the funds.
+    * @return A uint256 specifying the amount of tokens still available for the spender.
+    */
+    function allowance(address _owner, address _spender) public view returns (uint256) {
+        return allowed[_owner][_spender];
+    }
+
+    /**
+    * @dev Set whether the token is transferable or not
+    * @param _allowTransfer Should token be transferable
+    */
+    function setAllowTransfer(bool _allowTransfer) public {
+        allowTransfer_ = _allowTransfer;
+    }
+
+    /**
+    * @dev Transfer token for a specified address
+    * @param _to The address to transfer to.
+    * @param _value The amount to be transferred.
+    */
+    function transfer(address _to, uint256 _value) public returns (bool) {
+        if (!allowTransfer_ || _to == address(0) || _value > balances[msg.sender]) {
+            return false;
+        }
+
+        balances[msg.sender] = balances[msg.sender] - _value;
+        balances[_to] = balances[_to] + _value;
+        emit Transfer(msg.sender, _to, _value);
+        return true;
+    }
+
+    /**
+    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
+    * Beware that changing an allowance with this method brings the risk that someone may use both the old
+    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
+    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
+    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+    * @param _spender The address which will spend the funds.
+    * @param _value The amount of tokens to be spent.
+    */
+    function approve(address _spender, uint256 _value) public returns (bool) {
+        // Assume we want to protect for the race condition
+        if (allowed[msg.sender][_spender] != 0) {
+            return false;
+        }
+
+        allowed[msg.sender][_spender] = _value;
+        emit Approval(msg.sender, _spender, _value);
+        return true;
+    }
+
+    /**
+    * @dev Transfer tokens from one address to another
+    * @param _from address The address which you want to send tokens from
+    * @param _to address The address which you want to transfer to
+    * @param _value uint256 the amount of tokens to be transferred
+    */
+    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {
+        if (!allowTransfer_ ||
+            _to == address(0) ||
+            _value > balances[_from] ||
+            _value > allowed[_from][msg.sender]
+        ) {
+            return false;
+        }
+
+        balances[_from] = balances[_from] - _value;
+        balances[_to] = balances[_to] + _value;
+        allowed[_from][msg.sender] = allowed[_from][msg.sender] - _value;
+        emit Transfer(_from, _to, _value);
+        return true;
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnMissingMock.sol b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnMissingMock.sol
new file mode 100644
index 0000000..6668da2
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/mocks/lib/token/TokenReturnMissingMock.sol
@@ -0,0 +1,105 @@
+// Non-standards compliant token that is missing return values for
+// `transfer()`, `transferFrom()`, and `approve().
+// Modified from https://github.com/OpenZeppelin/openzeppelin-solidity/blob/a9f910d34f0ab33a1ae5e714f69f9596a02b4d91/contracts/token/ERC20/StandardToken.sol
+
+pragma solidity 0.4.24;
+
+import "../../../../lib/math/SafeMath.sol";
+
+
+contract TokenReturnMissingMock {
+    using SafeMath for uint256;
+    mapping (address => uint256) private balances;
+    mapping (address => mapping (address => uint256)) private allowed;
+    uint256 private totalSupply_;
+    bool private allowTransfer_;
+
+    event Approval(address indexed owner, address indexed spender, uint256 value);
+    event Transfer(address indexed from, address indexed to, uint256 value);
+
+    // Allow us to set the inital balance for an account on construction
+    constructor(address initialAccount, uint256 initialBalance) public {
+        balances[initialAccount] = initialBalance;
+        totalSupply_ = initialBalance;
+        allowTransfer_ = true;
+    }
+
+    function totalSupply() public view returns (uint256) { return totalSupply_; }
+
+    /**
+    * @dev Gets the balance of the specified address.
+    * @param _owner The address to query the the balance of.
+    * @return An uint256 representing the amount owned by the passed address.
+    */
+    function balanceOf(address _owner) public view returns (uint256) {
+        return balances[_owner];
+    }
+
+    /**
+    * @dev Set whether the token is transferable or not
+    * @param _allowTransfer Should token be transferable
+    */
+    function setAllowTransfer(bool _allowTransfer) public {
+        allowTransfer_ = _allowTransfer;
+    }
+
+    /**
+    * @dev Function to check the amount of tokens that an owner allowed to a spender.
+    * @param _owner address The address which owns the funds.
+    * @param _spender address The address which will spend the funds.
+    * @return A uint256 specifying the amount of tokens still available for the spender.
+    */
+    function allowance(address _owner, address _spender) public view returns (uint256) {
+        return allowed[_owner][_spender];
+    }
+
+    /**
+    * @dev Transfer token for a specified address
+    * @param _to The address to transfer to.
+    * @param _value The amount to be transferred.
+    */
+    function transfer(address _to, uint256 _value) public {
+        require(allowTransfer_);
+        require(_value <= balances[msg.sender]);
+        require(_to != address(0));
+
+        balances[msg.sender] = balances[msg.sender].sub(_value);
+        balances[_to] = balances[_to].add(_value);
+        emit Transfer(msg.sender, _to, _value);
+    }
+
+    /**
+    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.
+    * Beware that changing an allowance with this method brings the risk that someone may use both the old
+    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this
+    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:
+    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
+    * @param _spender The address which will spend the funds.
+    * @param _value The amount of tokens to be spent.
+    */
+    function approve(address _spender, uint256 _value) public {
+        // Assume we want to protect for the race condition
+        require(allowed[msg.sender][_spender] == 0);
+
+        allowed[msg.sender][_spender] = _value;
+        emit Approval(msg.sender, _spender, _value);
+    }
+
+    /**
+    * @dev Transfer tokens from one address to another
+    * @param _from address The address which you want to send tokens from
+    * @param _to address The address which you want to transfer to
+    * @param _value uint256 the amount of tokens to be transferred
+    */
+    function transferFrom(address _from, address _to, uint256 _value) public {
+        require(allowTransfer_);
+        require(_value <= balances[_from]);
+        require(_value <= allowed[_from][msg.sender]);
+        require(_to != address(0));
+
+        balances[_from] = balances[_from].sub(_value);
+        balances[_to] = balances[_to].add(_value);
+        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);
+        emit Transfer(_from, _to, _value);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/tests/TestACLInterpreter.sol b/node_modules/@aragon/os/contracts/test/tests/TestACLInterpreter.sol
new file mode 100644
index 0000000..05bb927
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/tests/TestACLInterpreter.sol
@@ -0,0 +1,266 @@
+pragma solidity 0.4.24;
+
+import "../../acl/ACL.sol";
+import "../helpers/Assert.sol";
+import "../helpers/ACLHelper.sol";
+
+
+contract TestACLInterpreter is ACL, ACLHelper {
+    function testEqualityUint() public {
+        // Assert param 0 is equal to 10, given that params are [10, 11]
+        assertEval(arr(uint256(10), 11), 0, Op.EQ, 10, true);
+        assertEval(arr(uint256(10), 11), 1, Op.EQ, 10, false);
+        assertEval(arr(uint256(10), 11), 1, Op.EQ, 11, true);
+    }
+
+    function testEqualityAddr() public {
+        assertEval(arr(msg.sender), 0, Op.EQ, uint256(msg.sender), true);
+        assertEval(arr(msg.sender), 0, Op.EQ, uint256(this), false);
+    }
+
+    function testEqualityBytes() public {
+        assertEval(arr(keccak256("hi")), 0, Op.EQ, uint256(keccak256("hi")), true);
+        assertEval(arr(keccak256("hi")), 0, Op.EQ, uint256(keccak256("bye")), false);
+    }
+
+    function testInequalityUint() public {
+        assertEval(arr(uint256(10), 11), 0, Op.NEQ, 10, false);
+        assertEval(arr(uint256(10), 11), 1, Op.NEQ, 10, true);
+        assertEval(arr(uint256(10), 11), 1, Op.NEQ, 11, false);
+    }
+
+    function testInequalityBytes() public {
+        assertEval(arr(keccak256("hi")), 0, Op.NEQ, uint256(keccak256("hi")), false);
+        assertEval(arr(keccak256("hi")), 0, Op.NEQ, uint256(keccak256("bye")), true);
+    }
+
+    function testInequalityAddr() public {
+        assertEval(arr(msg.sender), 0, Op.NEQ, uint256(msg.sender), false);
+        assertEval(arr(msg.sender), 0, Op.NEQ, uint256(this), true);
+    }
+
+    function testGreatherThan() public {
+        assertEval(arr(uint256(10), 11), 0, Op.GT, 9, true);
+        assertEval(arr(uint256(10), 11), 0, Op.GT, 10, false);
+        assertEval(arr(uint256(10), 11), 1, Op.GT, 10, true);
+    }
+
+    function testLessThan() public {
+        assertEval(arr(uint256(10), 11), 0, Op.LT, 9, false);
+        assertEval(arr(uint256(9), 11), 0, Op.LT, 10, true);
+        assertEval(arr(uint256(10), 11), 1, Op.LT, 10, false);
+    }
+
+    function testGreatherThanOrEqual() public {
+        assertEval(arr(uint256(10), 11), 0, Op.GTE, 9, true);
+        assertEval(arr(uint256(10), 11), 0, Op.GTE, 10, true);
+        assertEval(arr(uint256(10), 11), 1, Op.GTE, 12, false);
+    }
+
+    function testLessThanOrEqual() public {
+        assertEval(arr(uint256(10), 11), 0, Op.LTE, 9, false);
+        assertEval(arr(uint256(9), 11), 0, Op.LTE, 10, true);
+        assertEval(arr(uint256(10), 11), 1, Op.LTE, 11, true);
+    }
+
+    function testTimestamp() public {
+        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.EQ, uint256(block.timestamp), true);
+        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.EQ, uint256(1), false);
+        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.GT, uint256(1), true);
+    }
+
+    function testBlockNumber() public {
+        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.EQ, uint256(block.number), true);
+        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.EQ, uint256(1), false);
+        assertEval(arr(), BLOCK_NUMBER_PARAM_ID, Op.GT, uint256(block.number - 1), true);
+    }
+
+    function testOracle() public {
+        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new AcceptOracle()), true);
+        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new RejectOracle()), false);
+        assertEval(arr(), ORACLE_PARAM_ID, Op.NEQ, uint256(new RejectOracle()), true);
+
+        // doesn't revert even if oracle reverts
+        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new RevertOracle()), false);
+        // if returned data size is not correct, returns false
+        assertEval(arr(), ORACLE_PARAM_ID, Op.EQ, uint256(new EmptyDataReturnOracle()), false);
+
+        // conditional oracle returns true if first param > 0
+        ConditionalOracle conditionalOracle = new ConditionalOracle();
+
+        assertEval(arr(uint256(1)), ORACLE_PARAM_ID, Op.EQ, uint256(conditionalOracle), true);
+        assertEval(arr(uint256(0), uint256(1)), ORACLE_PARAM_ID, Op.EQ, uint256(conditionalOracle), false);
+    }
+
+    function testReturn() public {
+        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(1), true);
+        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(0), false);
+        assertEval(arr(), PARAM_VALUE_PARAM_ID, Op.RET, uint256(100), true);
+        assertEval(arr(), TIMESTAMP_PARAM_ID, Op.RET, uint256(0), true);
+    }
+
+    function testNot() public {
+        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);
+        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);
+
+        Param memory notOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.NOT), encodeOperator(1, 0));
+        Param[] memory params = new Param[](2);
+
+        // !true == false
+        params[0] = notOp;
+        params[1] = retTrue;
+        assertEval(params, false);
+
+        // !false == true
+        params[1] = retFalse;
+        assertEval(params, true);
+    }
+
+    function testComplexCombination() public {
+        // if (oracle and block number > block number - 1) then arg 0 < 10 or oracle else false
+        Param[] memory params = new Param[](7);
+        params[0] = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(1, 4, 6));
+        params[1] = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(2, 3));
+        params[2] = Param(ORACLE_PARAM_ID, uint8(Op.EQ), uint240(new AcceptOracle()));
+        params[3] = Param(BLOCK_NUMBER_PARAM_ID, uint8(Op.GT), uint240(block.number - 1));
+        params[4] = Param(LOGIC_OP_PARAM_ID, uint8(Op.OR), encodeOperator(5, 2));
+        params[5] = Param(0, uint8(Op.LT), uint240(10));
+        params[6] = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);
+
+        assertEval(params, arr(uint256(10)), true);
+
+        params[4] = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(5, 2));
+        assertEval(params, arr(uint256(10)), false);
+    }
+
+    function testParamOutOfBoundsFail() public {
+        Param[] memory params = new Param[](2);
+
+        params[1] = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);
+        assertEval(params, arr(uint256(10)), false);
+
+        params[0] = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(2, 2, 2));
+        assertEval(params, arr(uint256(10)), false);
+    }
+
+    function testArgOutOfBoundsFail() public {
+        assertEval(arr(uint256(10), 11), 3, Op.EQ, 10, false);
+    }
+
+    function testIfElse() public {
+        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);
+        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);
+
+        // If 1 then 2 else 3
+        Param memory ifOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.IF_ELSE), encodeIfElse(1, 2, 3));
+        Param[] memory params = new Param[](4);
+
+        // true ? true : false == true
+        params[0] = ifOp;
+        params[1] = retTrue;
+        params[2] = retTrue;
+        params[3] = retFalse;
+        assertEval(params, true);
+
+        // false ? true : false == false
+        params[1] = retFalse;
+        assertEval(params, false);
+    }
+
+    function testCombinators() public {
+        Param memory retTrue = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 1);
+        Param memory retFalse = Param(PARAM_VALUE_PARAM_ID, uint8(Op.RET), 0);
+
+        // OR param at index 1 or param 2
+        Param memory orOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.OR), encodeOperator(1, 2));
+        Param memory andOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.AND), encodeOperator(1, 2));
+        Param memory xorOp = Param(LOGIC_OP_PARAM_ID, uint8(Op.XOR), encodeOperator(1, 2));
+
+        Param[] memory params = new Param[](3);
+
+        // or true true == true
+        params[0] = orOp;
+        params[1] = retTrue;
+        params[2] = retTrue;
+        assertEval(params, true);
+
+        // or false true == true
+        params[1] = retFalse;
+        assertEval(params, true);
+
+        // or true false == true
+        params[1] = retTrue;
+        params[2] = retFalse;
+        assertEval(params, true);
+
+        // or false false == false
+        params[1] = retFalse;
+        assertEval(params, false);
+
+        // and false false == false
+        params[0] = andOp;
+        assertEval(params, false);
+
+        // and true false == false
+        params[1] = retTrue;
+        assertEval(params, false);
+
+        // and false true == false
+        params[1] = retFalse;
+        params[2] = retTrue;
+        assertEval(params, false);
+
+        // and true true == true
+        params[1] = retTrue;
+        params[2] = retTrue;
+        assertEval(params, true);
+
+        // xor true true == false
+        params[0] = xorOp;
+        assertEval(params, false);
+
+        // xor false true == true
+        params[1] = retFalse;
+        assertEval(params, true);
+
+        // xor true false == true
+        params[1] = retTrue;
+        params[2] = retFalse;
+        assertEval(params, true);
+
+        // xor false false == false
+        params[1] = retFalse;
+        assertEval(params, false);
+    }
+
+
+    function assertEval(uint256[] memory args, uint8 argId, Op op, uint256 value, bool expected) internal {
+        Param[] memory params = new Param[](1);
+        params[0] = Param(argId, uint8(op), uint240(value));
+        assertEval(params, args, expected);
+    }
+
+    function assertEval(Param[] memory params, bool expected) internal {
+        assertEval(params, new uint256[](0), expected);
+    }
+
+    function assertEval(Param[] memory params, uint256[] memory args, bool expected) internal {
+        bytes32 paramHash = encodeAndSaveParams(params);
+        bool allow = _evalParam(paramHash, 0, address(0), address(0), bytes32(0), args);
+
+        Assert.equal(allow, expected, "eval got unexpected result");
+    }
+
+    event LogParam(bytes32 param);
+    function encodeAndSaveParams(Param[] memory params) internal returns (bytes32) {
+        uint256[] memory encodedParams = new uint256[](params.length);
+
+        for (uint256 i = 0; i < params.length; i++) {
+            Param memory param = params[i];
+            encodedParams[i] = (uint256(param.id) << 248) + (uint256(param.op) << 240) + param.value;
+            emit LogParam(bytes32(encodedParams[i]));
+        }
+
+        return _saveParams(encodedParams);
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/tests/TestConversionHelpers.sol b/node_modules/@aragon/os/contracts/test/tests/TestConversionHelpers.sol
new file mode 100644
index 0000000..ea7da4c
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/tests/TestConversionHelpers.sol
@@ -0,0 +1,180 @@
+pragma solidity 0.4.24;
+
+import "../helpers/Assert.sol";
+import "../helpers/ThrowProxy.sol";
+
+import "../../common/ConversionHelpers.sol";
+
+
+contract InvalidBytesLengthConversionThrows {
+    function tryConvertLength(uint256 _badLength) public {
+        bytes memory arr = new bytes(_badLength);
+
+        // Do failing conversion
+        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);
+    }
+}
+
+
+contract TestConversionHelpers {
+    uint256 constant internal FIRST = uint256(keccak256("0"));
+    uint256 constant internal SECOND = uint256(keccak256("1"));
+    uint256 constant internal THIRD = uint256(keccak256("2"));
+
+    function testUintArrayConvertedToBytes() public {
+        uint256[] memory arr = new uint256[](3);
+        arr[0] = FIRST;
+        arr[1] = SECOND;
+        arr[2] = THIRD;
+        uint256 arrLength = arr.length;
+
+        // Do conversion
+        bytes memory arrBytes = ConversionHelpers.dangerouslyCastUintArrayToBytes(arr);
+
+        // Check length
+        Assert.equal(arrBytes.length, arrLength * 32, "should have correct length as bytes array");
+
+        // Check values
+        assertValues(arrBytes);
+
+        // Check memory position (conversion should be in place)
+        uint256 arrMemLoc;
+        uint256 arrBytesMemLoc;
+        assembly {
+            arrMemLoc := arr
+            arrBytesMemLoc := arrBytes
+        }
+        Assert.equal(arrMemLoc, arrBytesMemLoc, "should have same memory location after conversion");
+    }
+
+    function testUintArrayIntactIfConvertedBack() public {
+        uint256[] memory arr = new uint256[](3);
+        arr[0] = FIRST;
+        arr[1] = SECOND;
+        arr[2] = THIRD;
+        uint256 arrLength = arr.length;
+
+        // Convert to and back
+        bytes memory arrBytes = ConversionHelpers.dangerouslyCastUintArrayToBytes(arr);
+        uint256[] memory arrReconverted = ConversionHelpers.dangerouslyCastBytesToUintArray(arrBytes);
+
+        // Check length
+        Assert.equal(arrLength, arrReconverted.length, "should have correct length after reconverting");
+
+        // Check values
+        assertValues(arrReconverted);
+
+        // Check memory position (conversion should be in place)
+        uint256 arrMemLoc;
+        uint256 arrReconvertedMemLoc;
+        assembly {
+            arrMemLoc := arr
+            arrReconvertedMemLoc := arrReconverted
+        }
+        Assert.equal(arrMemLoc, arrReconvertedMemLoc, "should have same memory location after reconverting");
+    }
+
+    function testBytesConvertedToUintArray() public {
+        bytes memory arr = new bytes(96);
+
+        // Fill in bytes arr
+        uint256 first = FIRST;
+        uint256 second = SECOND;
+        uint256 third = THIRD;
+        assembly {
+            mstore(add(arr, 0x20), first)
+            mstore(add(arr, 0x40), second)
+            mstore(add(arr, 0x60), third)
+        }
+        uint256 arrLength = arr.length;
+
+        // Do conversion
+        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);
+
+        // Check length
+        Assert.equal(arrUint.length, arrLength / 32, "should have correct length as uint256 array");
+
+        // Check values
+        assertValues(arrUint);
+
+        // Check memory position (conversion should be in place)
+        uint256 arrMemLoc;
+        uint256 arrUintMemLoc;
+        assembly {
+            arrMemLoc := arr
+            arrUintMemLoc := arrUint
+        }
+        Assert.equal(arrMemLoc, arrUintMemLoc, "should have same memory location after conversion");
+    }
+
+    function testBytesIntactIfConvertedBack() public {
+        bytes memory arr = new bytes(96);
+
+        // Fill in bytes arr
+        uint256 first = FIRST;
+        uint256 second = SECOND;
+        uint256 third = THIRD;
+        assembly {
+            mstore(add(arr, 0x20), first)
+            mstore(add(arr, 0x40), second)
+            mstore(add(arr, 0x60), third)
+        }
+        uint256 arrLength = arr.length;
+
+        // Convert to and back
+        uint256[] memory arrUint = ConversionHelpers.dangerouslyCastBytesToUintArray(arr);
+        bytes memory arrReconverted = ConversionHelpers.dangerouslyCastUintArrayToBytes(arrUint);
+
+        // Check length
+        Assert.equal(arrLength, arrReconverted.length, "should have correct length after reconverting");
+
+        // Check values
+        assertValues(arrReconverted);
+
+        // Check memory position (conversion should be in place)
+        uint256 arrMemLoc;
+        uint256 arrReconvertedMemLoc;
+        assembly {
+            arrMemLoc := arr
+            arrReconvertedMemLoc := arrReconverted
+        }
+        Assert.equal(arrMemLoc, arrReconvertedMemLoc, "should have same memory location after reconverting");
+    }
+
+    function testBytesConversionThrowsOnInvalidLength() public {
+        InvalidBytesLengthConversionThrows thrower = new InvalidBytesLengthConversionThrows();
+        ThrowProxy throwProxy = new ThrowProxy(address(thrower));
+
+        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(15);
+        throwProxy.assertThrows("should have reverted due to invalid length");
+
+        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(36);
+        throwProxy.assertThrows("should have reverted due to invalid length");
+
+        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(61);
+        throwProxy.assertThrows("should have reverted due to invalid length");
+
+        InvalidBytesLengthConversionThrows(throwProxy).tryConvertLength(128);
+        throwProxy.assertItDoesntThrow("should not have reverted as length was valid");
+    }
+
+    function assertValues(uint256[] memory _data) public {
+        Assert.equal(_data[0], FIRST, "should have correct index value at 0");
+        Assert.equal(_data[1], SECOND, "should have correct index value at 1");
+        Assert.equal(_data[2], THIRD, "should have correct index value at 2");
+    }
+
+    function assertValues(bytes memory _data) public {
+        uint256 first;
+        uint256 second;
+        uint256 third;
+        assembly {
+            first := mload(add(_data, 0x20))
+            second := mload(add(_data, 0x40))
+            third := mload(add(_data, 0x60))
+        }
+        Assert.equal(first, FIRST, "should have correct first value");
+        Assert.equal(second, SECOND, "should have correct second value");
+        Assert.equal(third, THIRD, "should have correct third value");
+    }
+}
diff --git a/node_modules/@aragon/os/contracts/test/tests/TestDelegateProxy.sol b/node_modules/@aragon/os/contracts/test/tests/TestDelegateProxy.sol
new file mode 100644
index 0000000..1ba5a83
--- /dev/null
+++ b/node_modules/@aragon/os/contracts/test/tests/TestDelegateProxy.sol
@@ -0,0 +1,77 @@
+pragma solidity 0.4.24;
+
+import "../helpers/Assert.sol";
+import "../helpers/ThrowProxy.sol";
+
+import "../../common/DelegateProxy.sol";
+import "../../evmscript/ScriptHelpers.sol";
+
+
+contract Target {
+    function dontReturn() public pure {}
+    function fail() public pure { revert(); }
+    function die() public { selfdestruct(0); }
+}
+
+
+contract TestDelegateProxy is DelegateProxy {
+    using ScriptHelpers for *;
+
+    Target target;
+    ThrowProxy throwProxy;
+
+    // Mock ERCProxy implementation
+    function implementation() public view returns (address) {
+        return this;
+    }
+
+    function proxyType() public pure returns (uint256) {
+        return FORWARDING;
+    }
+
+    // Tests
+    function beforeAll() public {
+        target = new Target();
+    }
+
+    function beforeEach() public {
+        throwProxy = new ThrowProxy(address(this));
+    }
+
+    function testFailIfNoContract() public {
+        TestDelegateProxy(throwProxy).noContract();
+        throwProxy.assertThrows("should have reverted if target is not a contract");
+    }
+
+    function noContract() public {
+        delegatedFwd(address(0x1234), target.dontReturn.selector.toBytes());
+    }
+
+    function testFailIfReverts() public {
+        TestDelegateProxy(throwProxy).revertCall();
+        throwProxy.assertThrows("should have reverted if call reverted");
+    }
+
+    function revertCall() public {
+        delegatedFwd(target, target.fail.selector.toBytes());
+    }
+
+    function testIsContractZero() public {
+        bool result = isContract(address(0));
+        Assert.isFalse(result, "should return false");
+    }
+
+    function testIsContractAddress() public {
+        address nonContract = 0x1234;
+        bool result = isContract(nonContract);
+        Assert.isFalse(result, "should return false");
+    }
+
+    // keep as last test as it will kill this contract
+    function testDieIfMinReturn0() public {
+        Assert.isTrue(true, ''); // Make at least one assertion to satisfy the runner
+
+        delegatedFwd(target, target.die.selector.toBytes());
+        Assert.fail('should be dead');
+    }
+}
diff --git a/node_modules/@aragon/os/scripts/deploy-apm.js b/node_modules/@aragon/os/scripts/deploy-apm.js
index 22d79a6..af46675 100644
--- a/node_modules/@aragon/os/scripts/deploy-apm.js
+++ b/node_modules/@aragon/os/scripts/deploy-apm.js
@@ -61,7 +61,7 @@ module.exports = async (
     ens = (await deployENS(null, { artifacts, owner, verbose: false })).ens
     ensAddress = ens.address
   } else {
-    ens = ENS.at(ensAddress)
+    ens = await ENS.at(ensAddress)
   }
 
   log('ENS:', ensAddress)
@@ -80,7 +80,7 @@ module.exports = async (
 
   let daoFactory
   if (daoFactoryAddress) {
-    daoFactory = DAOFactory.at(daoFactoryAddress)
+    daoFactory = await sDAOFactory.at(daoFactoryAddress)
     const hasEVMScripts = await daoFactory.regFactory() !== ZERO_ADDR
 
     log(`Using provided DAOFactory (with${hasEVMScripts ? '' : 'out' } EVMScripts):`, daoFactoryAddress)
@@ -96,7 +96,7 @@ module.exports = async (
     apmRepoBase.address,
     ensSubdomainRegistrarBase.address,
     ensAddress,
-    '0x00'
+    ZERO_ADDR
   )
   await logDeploy(apmFactory, { verbose })
 
@@ -118,8 +118,9 @@ module.exports = async (
     }
   }
 
-  log('Deploying APM...')
-  const receipt = await apmFactory.newAPM(tldHash, labelHash, owner)
+  const epoch = await web3.cfx.getEpochNumber() - 100;
+  log(`Deploying APM (epoch: ${epoch})...`)
+  const receipt = await apmFactory.newAPM(tldHash, labelHash, owner, epoch)
 
   log('=========')
   const apmAddr = receipt.logs.filter(l => l.event == 'DeployAPM')[0].args.apm
@@ -135,7 +136,7 @@ module.exports = async (
     return {
       apmFactory,
       ens,
-      apm: APMRegistry.at(apmAddr),
+      apm: await APMRegistry.at(apmAddr),
     }
   }
 }
